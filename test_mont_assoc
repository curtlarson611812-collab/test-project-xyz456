warning: speedbitcrack@0.1.0: Successfully opened valuable_p2pk_pubkeys.txt for bias computation
   Compiling speedbitcrack v0.1.0 (/data/Projects/SpeedBitCrackV3)
warning: unused import: `anyhow`
  --> src/math/secp.rs:14:14
   |
14 | use anyhow::{anyhow, Result};
   |              ^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unnecessary parentheses around assigned value
   --> src/math/bigint.rs:698:17
    |
698 |         let k = ((modulus.bit_length() + 63) / 64); // Correct: ceil(bit_length / 64), 4 for 256-bit
    |                 ^                                ^
    |
    = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
    |
698 -         let k = ((modulus.bit_length() + 63) / 64); // Correct: ceil(bit_length / 64), 4 for 256-bit
698 +         let k = (modulus.bit_length() + 63) / 64; // Correct: ceil(bit_length / 64), 4 for 256-bit
    |

warning: unnecessary parentheses around assigned value
   --> src/math/bigint.rs:743:17
    |
743 |         let b = (self.modulus.bit_length() as u32); // 256
    |                 ^                                ^
    |
help: remove these parentheses
    |
743 -         let b = (self.modulus.bit_length() as u32); // 256
743 +         let b = self.modulus.bit_length() as u32; // 256
    |

warning: unnecessary parentheses around assigned value
   --> src/math/bigint.rs:894:27
    |
894 |         let mut r: i128 = (1i128 << 64); // 2^64
    |                           ^           ^
    |
help: remove these parentheses
    |
894 -         let mut r: i128 = (1i128 << 64); // 2^64
894 +         let mut r: i128 = 1i128 << 64; // 2^64
    |

warning: unused import: `num_bigint::BigUint`
    --> src/math/bigint.rs:1282:9
     |
1282 |     use num_bigint::BigUint;
     |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::time::Duration`
    --> src/math/bigint.rs:1283:9
     |
1283 |     use std::time::Duration;
     |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::ops::Mul`
 --> src/math/constants.rs:7:5
  |
7 | use std::ops::Mul;
  |     ^^^^^^^^^^^^^

warning: unused import: `super::*`
 --> src/math/tests.rs:3:9
  |
3 |     use super::*;
  |         ^^^^^^^^

warning: unused import: `num_traits::cast::ToPrimitive`
  --> src/kangaroo/manager.rs:23:5
   |
23 | use num_traits::cast::ToPrimitive;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `super::*`
   --> src/kangaroo/manager.rs:827:9
    |
827 |     use super::*;
    |         ^^^^^^^^

warning: unused import: `crate::config::Config`
   --> src/kangaroo/manager.rs:828:9
    |
828 |     use crate::config::Config;
    |         ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `super::*`
 --> src/kangaroo/tests.rs:3:9
  |
3 |     use super::*;
  |         ^^^^^^^^

warning: unused import: `crate::types::Point`
 --> src/kangaroo/tests.rs:5:9
  |
5 |     use crate::types::Point;
  |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `super::*`
   --> src/gpu/backends/cuda_backend.rs:913:9
    |
913 |     use super::*;
    |         ^^^^^^^^

warning: unused import: `crate::math::bigint::BigInt256`
   --> src/gpu/backends/cuda_backend.rs:914:9
    |
914 |     use crate::math::bigint::BigInt256;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused doc comment
   --> src/utils/bias.rs:97:1
    |
 97 | / /// Pre-computed bias database for Magic 9 sniper mode
 98 | | /// Auto-generated at build time from valuable_p2pk_pubkeys.txt
 99 | | /// Format: (mod3, mod9, mod27, mod81, hamming_weight) for each of the 9 pubkeys
100 | | /// Indices: [9379, 28687, 33098, 12457, 18902, 21543, 27891, 31234, 4567]
101 | | /// Generated by build.rs from cluster analysis
    | |_----------------------------------------------^
    |   |
    |   rustdoc does not generate documentation for macro invocations
    |
    = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion
    = note: `#[warn(unused_doc_comments)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `zerocopy::IntoBytes`
 --> src/utils/bias.rs:7:5
  |
7 | use zerocopy::IntoBytes;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `log::Log`
  --> src/utils/output.rs:31:9
   |
31 |     use log::Log;
   |         ^^^^^^^^

warning: unused import: `std::sync::Arc`
   --> src/utils/output.rs:387:9
    |
387 |     use std::sync::Arc;
    |         ^^^^^^^^^^^^^^

warning: unused import: `std::sync::atomic::AtomicBool`
   --> src/utils/output.rs:388:9
    |
388 |     use std::sync::atomic::AtomicBool;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `cudarc`
   --> src/security.rs:104:15
    |
104 |     #[cfg(not(feature = "cudarc"))]
    |               ^^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `cuda-runtime-sys`, `default`, `fuzz`, `laptop`, `legacy`, `libfuzzer-sys`, `phase4`, `portable_simd`, `rustacuda`, `smoke`, `vulkano`, and `wgpu`
    = help: consider adding `cudarc` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
    = note: `#[warn(unexpected_cfgs)]` on by default

warning: unused import: `BigInt512`
 --> src/simple_test.rs:2:56
  |
2 | use crate::math::{secp::Secp256k1, bigint::{BigInt256, BigInt512}};
  |                                                        ^^^^^^^^^

warning: variable does not need to be mutable
   --> src/kangaroo/collision.rs:387:13
    |
387 |         let mut tame_walk = tame.clone();
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
   --> src/kangaroo/collision.rs:427:13
    |
427 |         let mut wild_walk = wild.clone();
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

error[E0599]: no method named `to_u64_array` found for enum `std::result::Result<T, E>` in the current scope
    --> src/math/secp.rs:1500:48
     |
1500 |         assert_eq!(four_g_affine.x, expected_x.to_u64_array());
     |                                                ^^^^^^^^^^^^ method not found in `std::result::Result<math::bigint::BigInt256, std::string::String>`
     |
note: the method `to_u64_array` exists on the type `math::bigint::BigInt256`
    --> src/math/bigint.rs:436:5
     |
 436 |     pub fn to_u64_array(self) -> [u64; 4] {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `math::bigint::BigInt256` value, panicking if the value is a `Result::Err`
     |
1500 |         assert_eq!(four_g_affine.x, expected_x.expect("REASON").to_u64_array());
     |                                               +++++++++++++++++

error[E0599]: no method named `to_u64_array` found for enum `std::result::Result<T, E>` in the current scope
    --> src/math/secp.rs:1501:48
     |
1501 |         assert_eq!(four_g_affine.y, expected_y.to_u64_array());
     |                                                ^^^^^^^^^^^^ method not found in `std::result::Result<math::bigint::BigInt256, std::string::String>`
     |
note: the method `to_u64_array` exists on the type `math::bigint::BigInt256`
    --> src/math/bigint.rs:436:5
     |
 436 |     pub fn to_u64_array(self) -> [u64; 4] {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `math::bigint::BigInt256` value, panicking if the value is a `Result::Err`
     |
1501 |         assert_eq!(four_g_affine.y, expected_y.expect("REASON").to_u64_array());
     |                                               +++++++++++++++++

error[E0599]: no method named `known_3g` found for struct `secp::Secp256k1` in the current scope
    --> src/math/secp.rs:1675:34
     |
  78 | pub struct Secp256k1 {
     | -------------------- method `known_3g` not found for this struct
...
1675 |             let expected = curve.known_3g();
     |                            ------^^^^^^^^--
     |                            |     |
     |                            |     this is an associated function, not a method
     |                            help: use associated function syntax instead: `secp::Secp256k1::known_3g()`
     |
     = note: found the following associated functions; to be used as methods, functions must have a `self` parameter
note: the candidate is defined in an impl for the type `secp::Secp256k1`
    --> src/math/secp.rs:29:5
     |
  29 |     pub fn known_3g() -> (BigInt256, BigInt256) {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
    --> src/math/secp.rs:1709:45
     |
1709 |             let _ = curve.mul_constant_time(&medium_k, &curve.g).unwrap();
     |                           ----------------- ^^^^^^^^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                           |
     |                           arguments to this method are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: method defined here
    --> src/math/secp.rs:488:12
     |
 488 |     pub fn mul_constant_time(&self, k: &BigInt256, p: &Point) -> Result<Point, Box<dyn Error>> {
     |            ^^^^^^^^^^^^^^^^^        -------------

error[E0308]: mismatched types
    --> src/math/secp.rs:1717:45
     |
1717 |             let _ = curve.mul_constant_time(&large_k, &curve.g).unwrap();
     |                           ----------------- ^^^^^^^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                           |
     |                           arguments to this method are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: method defined here
    --> src/math/secp.rs:488:12
     |
 488 |     pub fn mul_constant_time(&self, k: &BigInt256, p: &Point) -> Result<Point, Box<dyn Error>> {
     |            ^^^^^^^^^^^^^^^^^        -------------

error[E0308]: mismatched types
    --> src/math/secp.rs:1750:41
     |
1750 |             let _ = curve.glv_decompose(&large_k);
     |                           ------------- ^^^^^^^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                           |
     |                           arguments to this method are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: method defined here
    --> src/math/secp.rs:587:8
     |
 587 |     fn glv_decompose(&self, k: &BigInt256) -> (BigInt256, BigInt256) {
     |        ^^^^^^^^^^^^^        -------------

error[E0308]: mismatched types
    --> src/math/secp.rs:1772:45
     |
1772 |             let _ = curve.mul_constant_time(&large_k, &curve.g).unwrap();
     |                           ----------------- ^^^^^^^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                           |
     |                           arguments to this method are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: method defined here
    --> src/math/secp.rs:488:12
     |
 488 |     pub fn mul_constant_time(&self, k: &BigInt256, p: &Point) -> Result<Point, Box<dyn Error>> {
     |            ^^^^^^^^^^^^^^^^^        -------------

error[E0599]: no method named `bit` found for enum `std::result::Result<T, E>` in the current scope
    --> src/math/secp.rs:1784:28
     |
1784 |                 if large_k.bit(i) {
     |                            ^^^ method not found in `std::result::Result<math::bigint::BigInt256, std::string::String>`
     |
note: the method `bit` exists on the type `math::bigint::BigInt256`
    --> src/math/bigint.rs:614:5
     |
 614 |     pub fn bit(&self, pos: usize) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `math::bigint::BigInt256` value, panicking if the value is a `Result::Err`
     |
1784 |                 if large_k.expect("REASON").bit(i) {
     |                           +++++++++++++++++

error[E0599]: no method named `unwrap` found for struct `types::Point` in the current scope
    --> src/math/secp.rs:1785:59
     |
1785 |                     result = curve.add(&result, &current).unwrap();
     |                                                           ^^^^^^ method not found in `types::Point`
     |
    ::: src/types.rs:42:1
     |
  42 | pub struct Point {
     | ---------------- method `unwrap` not found for this struct

error[E0599]: no method named `unwrap` found for struct `types::Point` in the current scope
    --> src/math/secp.rs:1816:52
     |
1816 |         let expected = curve.add(&six_g, &curve.g).unwrap();
     |                                                    ^^^^^^ method not found in `types::Point`
     |
    ::: src/types.rs:42:1
     |
  42 | pub struct Point {
     | ---------------- method `unwrap` not found for this struct

error[E0308]: mismatched types
    --> src/math/secp.rs:1837:56
     |
1837 |         let (k1_large, k2_large) = curve.glv_decompose(&large_k);
     |                                          ------------- ^^^^^^^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                                          |
     |                                          arguments to this method are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: method defined here
    --> src/math/secp.rs:587:8
     |
 587 |     fn glv_decompose(&self, k: &BigInt256) -> (BigInt256, BigInt256) {
     |        ^^^^^^^^^^^^^        -------------

error[E0308]: mismatched types
    --> src/math/secp.rs:1850:44
     |
1850 |         let expected = curve.barrett_n.sub(&large_k, &curve.n); // large_k - n for mod
     |                                        --- ^^^^^^^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                                        |
     |                                        arguments to this method are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: method defined here
    --> src/math/bigint.rs:805:12
     |
 805 |     pub fn sub(&self, a: &BigInt256, b: &BigInt256) -> BigInt256 {
     |            ^^^        -------------

error[E0308]: mismatched types
    --> src/math/bigint.rs:1344:33
     |
1344 |             let a_mod = if a >= &p { a - p.clone() } else { a };
     |                            -    ^^ expected `BigInt256`, found `&BigInt256`
     |                            |
     |                            expected because this is `math::bigint::BigInt256`
     |
help: consider removing the borrow
     |
1344 -             let a_mod = if a >= &p { a - p.clone() } else { a };
1344 +             let a_mod = if a >= p { a - p.clone() } else { a };
     |

error[E0308]: mismatched types
    --> src/math/bigint.rs:1345:33
     |
1345 |             let b_mod = if b >= &p { b - p.clone() } else { b };
     |                            -    ^^ expected `BigInt256`, found `&BigInt256`
     |                            |
     |                            expected because this is `math::bigint::BigInt256`
     |
help: consider removing the borrow
     |
1345 -             let b_mod = if b >= &p { b - p.clone() } else { b };
1345 +             let b_mod = if b >= p { b - p.clone() } else { b };
     |

error[E0308]: mismatched types
    --> src/math/bigint.rs:1375:38
     |
1375 |         let reduced = reducer.reduce(&max_val).expect("Barrett reduction failed");
     |                               ------ ^^^^^^^^ expected `&BigInt512`, found `&BigInt256`
     |                               |
     |                               arguments to this method are incorrect
     |
     = note: expected reference `&BigInt512`
                found reference `&math::bigint::BigInt256`
note: method defined here
    --> src/math/bigint.rs:725:12
     |
 725 |     pub fn reduce(&self, x: &BigInt512) -> Result<BigInt256, Box<dyn Error>> {
     |            ^^^^^^        -------------

error[E0308]: mismatched types
    --> src/math/bigint.rs:1381:35
     |
1381 |         assert_eq!(reducer.reduce(&small_val), small_val);
     |                            ------ ^^^^^^^^^^ expected `&BigInt512`, found `&BigInt256`
     |                            |
     |                            arguments to this method are incorrect
     |
     = note: expected reference `&BigInt512`
                found reference `&math::bigint::BigInt256`
note: method defined here
    --> src/math/bigint.rs:725:12
     |
 725 |     pub fn reduce(&self, x: &BigInt512) -> Result<BigInt256, Box<dyn Error>> {
     |            ^^^^^^        -------------

error[E0369]: binary operation `==` cannot be applied to type `std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>`
    --> src/math/bigint.rs:1381:9
     |
1381 |         assert_eq!(reducer.reduce(&small_val), small_val);
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     |         |
     |         std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>
     |         math::bigint::BigInt256
     |
note: `std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>` does not implement `PartialEq<math::bigint::BigInt256>`
    --> /rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/core/src/result.rs:557:1
     |
     = note: `std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>` is defined in another crate
     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
    --> src/math/bigint.rs:1409:43
     |
1409 |         let barrett = BarrettReducer::new(&p);
     |                       ------------------- ^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                       |
     |                       arguments to this function are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: associated function defined here
    --> src/math/bigint.rs:694:12
     |
 694 |     pub fn new(modulus: &BigInt256) -> Self {
     |            ^^^ -------------------

error[E0308]: mismatched types
    --> src/math/bigint.rs:1410:49
     |
1410 |         let montgomery = MontgomeryReducer::new(&p);
     |                          ---------------------- ^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                          |
     |                          arguments to this function are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: associated function defined here
    --> src/math/bigint.rs:836:12
     |
 836 |     pub fn new(modulus: &BigInt256) -> Self {
     |            ^^^ -------------------

error[E0308]: mismatched types
    --> src/math/bigint.rs:1421:34
     |
1421 |         assert!(barrett_result < p);
     |                 --------------   ^ expected `BigInt256`, found `Result<BigInt256, String>`
     |                 |
     |                 expected because this is `math::bigint::BigInt256`
     |
     = note: expected struct `math::bigint::BigInt256`
                  found enum `std::result::Result<math::bigint::BigInt256, std::string::String>`
help: consider using `Result::expect` to unwrap the `std::result::Result<math::bigint::BigInt256, std::string::String>` value, panicking if the value is a `Result::Err`
     |
1421 |         assert!(barrett_result < p.expect("REASON"));
     |                                   +++++++++++++++++

error[E0308]: mismatched types
    --> src/math/bigint.rs:1422:37
     |
1422 |         assert!(montgomery_result < p);
     |                 -----------------   ^ expected `BigInt256`, found `Result<BigInt256, String>`
     |                 |
     |                 expected because this is `math::bigint::BigInt256`
     |
     = note: expected struct `math::bigint::BigInt256`
                  found enum `std::result::Result<math::bigint::BigInt256, std::string::String>`
help: consider using `Result::expect` to unwrap the `std::result::Result<math::bigint::BigInt256, std::string::String>` value, panicking if the value is a `Result::Err`
     |
1422 |         assert!(montgomery_result < p.expect("REASON"));
     |                                      +++++++++++++++++

error[E0599]: no function or associated item named `mod_inverse_u64` found for struct `MontgomeryReducer` in the current scope
    --> src/math/bigint.rs:1430:44
     |
 820 | pub struct MontgomeryReducer {
     | ---------------------------- function or associated item `mod_inverse_u64` not found for this struct
...
1430 |         let inv_three = MontgomeryReducer::mod_inverse_u64(3, 17);
     |                                            ^^^^^^^^^^^^^^^ function or associated item not found in `MontgomeryReducer`
     |
note: if you're trying to build a new `MontgomeryReducer`, consider using `MontgomeryReducer::new` which returns `MontgomeryReducer`
    --> src/math/bigint.rs:836:5
     |
 836 |     pub fn new(modulus: &BigInt256) -> Self {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is a method `mod_inverse` with a similar name
     |
1430 -         let inv_three = MontgomeryReducer::mod_inverse_u64(3, 17);
1430 +         let inv_three = MontgomeryReducer::mod_inverse(3, 17);
     |

error[E0609]: no field `limbs` on type `std::result::Result<math::bigint::BigInt256, std::string::String>`
    --> src/math/bigint.rs:1443:22
     |
1443 |         assert_eq!(n.limbs[0] & 1, 1);
     |                      ^^^^^ unknown field
     |
help: one of the expressions' fields has a field of the same name
     |
1443 |         assert_eq!(n.unwrap().limbs[0] & 1, 1);
     |                      +++++++++

error[E0599]: no method named `get_bit` found for enum `std::result::Result<T, E>` in the current scope
    --> src/math/bigint.rs:1446:19
     |
1446 |         assert!(n.get_bit(0)); // LSB should be 1
     |                   ^^^^^^^ method not found in `std::result::Result<math::bigint::BigInt256, std::string::String>`
     |
note: the method `get_bit` exists on the type `math::bigint::BigInt256`
    --> src/math/bigint.rs:495:5
     |
 495 |     pub fn get_bit(&self, bit: usize) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `math::bigint::BigInt256` value, panicking if the value is a `Result::Err`
     |
1446 |         assert!(n.expect("REASON").get_bit(0)); // LSB should be 1
     |                  +++++++++++++++++

error[E0599]: no method named `bit_length` found for enum `std::result::Result<T, E>` in the current scope
    --> src/math/bigint.rs:1447:22
     |
1447 |         assert_eq!(n.bit_length(), 256); // Should be 256 bits
     |                      ^^^^^^^^^^ method not found in `std::result::Result<math::bigint::BigInt256, std::string::String>`
     |
note: the method `bit_length` exists on the type `math::bigint::BigInt256`
    --> src/math/bigint.rs:485:5
     |
 485 |     pub fn bit_length(&self) -> usize {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `math::bigint::BigInt256` value, panicking if the value is a `Result::Err`
     |
1447 |         assert_eq!(n.expect("REASON").bit_length(), 256); // Should be 256 bits
     |                     +++++++++++++++++

error[E0308]: mismatched types
    --> src/math/bigint.rs:1464:43
     |
1464 |         let reducer = BarrettReducer::new(p);
     |                       ------------------- ^ expected `&BigInt256`, found `Result<BigInt256, String>`
     |                       |
     |                       arguments to this function are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                     found enum `std::result::Result<math::bigint::BigInt256, std::string::String>`
note: associated function defined here
    --> src/math/bigint.rs:694:12
     |
 694 |     pub fn new(modulus: &BigInt256) -> Self {
     |            ^^^ -------------------

error[E0308]: mismatched types
    --> src/math/bigint.rs:1467:35
     |
1467 |         assert_eq!(reducer.reduce(&BigInt256::zero()), BigInt256::zero());
     |                            ------ ^^^^^^^^^^^^^^^^^^ expected `&BigInt512`, found `&BigInt256`
     |                            |
     |                            arguments to this method are incorrect
     |
     = note: expected reference `&BigInt512`
                found reference `&math::bigint::BigInt256`
note: method defined here
    --> src/math/bigint.rs:725:12
     |
 725 |     pub fn reduce(&self, x: &BigInt512) -> Result<BigInt256, Box<dyn Error>> {
     |            ^^^^^^        -------------

error[E0369]: binary operation `==` cannot be applied to type `std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>`
    --> src/math/bigint.rs:1467:9
     |
1467 |         assert_eq!(reducer.reduce(&BigInt256::zero()), BigInt256::zero());
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     |         |
     |         std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>
     |         math::bigint::BigInt256
     |
note: `std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>` does not implement `PartialEq<math::bigint::BigInt256>`
    --> /rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/core/src/result.rs:557:1
     |
     = note: `std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>` is defined in another crate
     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
    --> src/math/bigint.rs:1470:35
     |
1470 |         assert_eq!(reducer.reduce(&p), BigInt256::zero());
     |                            ------ ^^ expected `&BigInt512`, found `&Result<BigInt256, String>`
     |                            |
     |                            arguments to this method are incorrect
     |
     = note: expected reference `&BigInt512`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: method defined here
    --> src/math/bigint.rs:725:12
     |
 725 |     pub fn reduce(&self, x: &BigInt512) -> Result<BigInt256, Box<dyn Error>> {
     |            ^^^^^^        -------------

error[E0369]: binary operation `==` cannot be applied to type `std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>`
    --> src/math/bigint.rs:1470:9
     |
1470 |         assert_eq!(reducer.reduce(&p), BigInt256::zero());
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     |         |
     |         std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>
     |         math::bigint::BigInt256
     |
note: `std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>` does not implement `PartialEq<math::bigint::BigInt256>`
    --> /rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/core/src/result.rs:557:1
     |
     = note: `std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>` is defined in another crate
     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0369]: cannot add `std::result::Result<math::bigint::BigInt256, std::string::String>` to `std::result::Result<math::bigint::BigInt256, std::string::String>`
    --> src/math/bigint.rs:1473:23
     |
1473 |         let two_p = p + p;
     |                     - ^ - std::result::Result<math::bigint::BigInt256, std::string::String>
     |                     |
     |                     std::result::Result<math::bigint::BigInt256, std::string::String>
     |
note: `std::result::Result<math::bigint::BigInt256, std::string::String>` does not implement `std::ops::Add`
    --> /rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/core/src/result.rs:557:1
     |
     = note: `std::result::Result<math::bigint::BigInt256, std::string::String>` is defined in another crate

error[E0369]: binary operation `==` cannot be applied to type `std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>`
    --> src/math/bigint.rs:1474:9
     |
1474 |         assert_eq!(reducer.reduce(&two_p), BigInt256::zero());
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     |         |
     |         std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>
     |         math::bigint::BigInt256
     |
note: `std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>` does not implement `PartialEq<math::bigint::BigInt256>`
    --> /rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/core/src/result.rs:557:1
     |
     = note: `std::result::Result<math::bigint::BigInt256, Box<dyn StdError>>` is defined in another crate
     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
    --> src/math/bigint.rs:1490:47
     |
1490 |         let plain_mod = plain_product.div_rem(&p).1;
     |                                       ------- ^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                                       |
     |                                       arguments to this method are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: method defined here
    --> src/math/bigint.rs:505:12
     |
 505 |     pub fn div_rem(&self, divisor: &BigInt256) -> (BigInt256, BigInt256) {
     |            ^^^^^^^        -------------------

error[E0308]: mismatched types
    --> src/math/bigint.rs:1494:29
     |
1494 |         assert!(plain_mod < p); // This works but violates the rule
     |                 ---------   ^ expected `BigInt256`, found `Result<BigInt256, String>`
     |                 |
     |                 expected because this is `math::bigint::BigInt256`
     |
     = note: expected struct `math::bigint::BigInt256`
                  found enum `std::result::Result<math::bigint::BigInt256, std::string::String>`
help: consider using `Result::expect` to unwrap the `std::result::Result<math::bigint::BigInt256, std::string::String>` value, panicking if the value is a `Result::Err`
     |
1494 |         assert!(plain_mod < p.expect("REASON")); // This works but violates the rule
     |                              +++++++++++++++++

error[E0308]: mismatched types
    --> src/math/bigint.rs:1500:46
     |
1500 |         let reducer = MontgomeryReducer::new(&p);
     |                       ---------------------- ^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                       |
     |                       arguments to this function are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: associated function defined here
    --> src/math/bigint.rs:836:12
     |
 836 |     pub fn new(modulus: &BigInt256) -> Self {
     |            ^^^ -------------------

error[E0308]: mismatched types
    --> src/math/bigint.rs:1502:68
     |
1502 |         let inv = MontgomeryReducer::mod_inverse(&reducer, &three, &p).unwrap();
     |                   ------------------------------                   ^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                   |
     |                   arguments to this function are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: method defined here
    --> src/math/bigint.rs:1023:12
     |
1023 |     pub fn mod_inverse(&self, a: &BigInt256, modulus: &BigInt256) -> Option<BigInt256> {
     |            ^^^^^^^^^^^                       -------------------

error[E0599]: no method named `sub` found for enum `std::result::Result<T, E>` in the current scope
    --> src/math/bigint.rs:1509:27
     |
1509 |         let neg_three = p.sub(&three);
     |                           ^^^ method not found in `std::result::Result<math::bigint::BigInt256, std::string::String>`

error[E0308]: mismatched types
    --> src/math/bigint.rs:1510:76
     |
1510 |         let inv_neg = MontgomeryReducer::mod_inverse(&reducer, &neg_three, &p).unwrap();
     |                       ------------------------------                       ^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                       |
     |                       arguments to this function are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: method defined here
    --> src/math/bigint.rs:1023:12
     |
1023 |     pub fn mod_inverse(&self, a: &BigInt256, modulus: &BigInt256) -> Option<BigInt256> {
     |            ^^^^^^^^^^^                       -------------------

error[E0308]: mismatched types
    --> src/math/bigint.rs:1563:43
     |
1563 |         let mont = MontgomeryReducer::new(&p);
     |                    ---------------------- ^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                    |
     |                    arguments to this function are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: associated function defined here
    --> src/math/bigint.rs:836:12
     |
 836 |     pub fn new(modulus: &BigInt256) -> Self {
     |            ^^^ -------------------

error[E0308]: mismatched types
    --> src/math/bigint.rs:1564:43
     |
1564 |         let barrett = BarrettReducer::new(&p); // Use Barrett as naive baseline
     |                       ------------------- ^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                       |
     |                       arguments to this function are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: associated function defined here
    --> src/math/bigint.rs:694:12
     |
 694 |     pub fn new(modulus: &BigInt256) -> Self {
     |            ^^^ -------------------

error[E0599]: no method named `unwrap` found for struct `math::bigint::BigInt256` in the current scope
    --> src/math/bigint.rs:1581:46
     |
  14 | pub struct BigInt256 {
     | -------------------- method `unwrap` not found for this struct
...
1581 |             let a_mont = mont.convert_in(&a).unwrap();
     |                                              ^^^^^^ method not found in `math::bigint::BigInt256`

error[E0599]: no method named `unwrap` found for struct `math::bigint::BigInt256` in the current scope
    --> src/math/bigint.rs:1582:46
     |
  14 | pub struct BigInt256 {
     | -------------------- method `unwrap` not found for this struct
...
1582 |             let b_mont = mont.convert_in(&b).unwrap();
     |                                              ^^^^^^ method not found in `math::bigint::BigInt256`

error[E0599]: no method named `unwrap` found for struct `math::bigint::BigInt256` in the current scope
    --> src/math/bigint.rs:1607:42
     |
  14 | pub struct BigInt256 {
     | -------------------- method `unwrap` not found for this struct
...
1607 |         let a_mont = mont.convert_in(&a).unwrap();
     |                                          ^^^^^^ method not found in `math::bigint::BigInt256`

error[E0599]: no method named `unwrap` found for struct `math::bigint::BigInt256` in the current scope
    --> src/math/bigint.rs:1608:48
     |
  14 | pub struct BigInt256 {
     | -------------------- method `unwrap` not found for this struct
...
1608 |         let a_back = mont.convert_out(&a_mont).unwrap();
     |                                                ^^^^^^ method not found in `math::bigint::BigInt256`

error[E0599]: no method named `unwrap` found for struct `math::bigint::BigInt256` in the current scope
    --> src/math/bigint.rs:1613:42
     |
  14 | pub struct BigInt256 {
     | -------------------- method `unwrap` not found for this struct
...
1613 |         let b_mont = mont.convert_in(&b).unwrap();
     |                                          ^^^^^^ method not found in `math::bigint::BigInt256`

error[E0599]: no method named `unwrap` found for struct `math::bigint::BigInt256` in the current scope
    --> src/math/bigint.rs:1615:49
     |
  14 | pub struct BigInt256 {
     | -------------------- method `unwrap` not found for this struct
...
1615 |         let prod = mont.convert_out(&prod_mont).unwrap();
     |                                                 ^^^^^^ method not found in `math::bigint::BigInt256`

error[E0599]: no method named `unwrap` found for struct `math::bigint::BigInt256` in the current scope
    --> src/math/bigint.rs:1666:45
     |
  14 | pub struct BigInt256 {
     | -------------------- method `unwrap` not found for this struct
...
1666 |             let mont_x = mont.convert_in(x).unwrap();
     |                                             ^^^^^^ method not found in `math::bigint::BigInt256`

error[E0599]: no method named `unwrap` found for struct `math::bigint::BigInt256` in the current scope
    --> src/math/bigint.rs:1667:52
     |
  14 | pub struct BigInt256 {
     | -------------------- method `unwrap` not found for this struct
...
1667 |             let back_x = mont.convert_out(&mont_x).unwrap();
     |                                                    ^^^^^^ method not found in `math::bigint::BigInt256`

error[E0308]: mismatched types
    --> src/math/bigint.rs:1680:43
     |
1680 |         let barrett = BarrettReducer::new(&p);
     |                       ------------------- ^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                       |
     |                       arguments to this function are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: associated function defined here
    --> src/math/bigint.rs:694:12
     |
 694 |     pub fn new(modulus: &BigInt256) -> Self {
     |            ^^^ -------------------

error[E0308]: mismatched types
    --> src/math/bigint.rs:1700:43
     |
1700 |         let barrett = BarrettReducer::new(&p);
     |                       ------------------- ^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                       |
     |                       arguments to this function are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: associated function defined here
    --> src/math/bigint.rs:694:12
     |
 694 |     pub fn new(modulus: &BigInt256) -> Self {
     |            ^^^ -------------------

error[E0308]: mismatched types
    --> src/math/bigint.rs:1720:43
     |
1720 |         let barrett = BarrettReducer::new(&p);
     |                       ------------------- ^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
     |                       |
     |                       arguments to this function are incorrect
     |
     = note: expected reference `&math::bigint::BigInt256`
                found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: associated function defined here
    --> src/math/bigint.rs:694:12
     |
 694 |     pub fn new(modulus: &BigInt256) -> Self {
     |            ^^^ -------------------

error[E0599]: no function or associated item named `add` found for struct `BigInt512` in the current scope
    --> src/math/bigint.rs:1757:32
     |
  21 | pub struct BigInt512 {
     | -------------------- function or associated item `add` not found for this struct
...
1757 |         let two_p = BigInt512::add(&p_big, &p_big);
     |                                ^^^ function or associated item not found in `BigInt512`
     |
note: if you're trying to build a new `BigInt512` consider using one of the following associated functions:
      BigInt512::from_bigint256
      BigInt512::from_u64
      BigInt512::one
      BigInt512::zero
    --> src/math/bigint.rs:28:5
     |
  28 |     pub fn from_bigint256(x: &BigInt256) -> Self {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 187 |     pub fn from_u64(x: u64) -> Self {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 197 |     pub fn one() -> Self {
     |     ^^^^^^^^^^^^^^^^^^^^
...
 201 |     pub fn zero() -> Self {
     |     ^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is in scope
help: trait `Add` which provides `add` is implemented but not in scope; perhaps you want to import it
     |
1281 +     use std::ops::Add;
     |

error[E0599]: no method named `unwrap` found for struct `math::bigint::BigInt256` in the current scope
    --> src/math/bigint.rs:1789:42
     |
  14 | pub struct BigInt256 {
     | -------------------- method `unwrap` not found for this struct
...
1789 |         let a_mont = mont.convert_in(&a).unwrap();
     |                                          ^^^^^^ method not found in `math::bigint::BigInt256`

error[E0599]: no method named `unwrap` found for struct `math::bigint::BigInt256` in the current scope
    --> src/math/bigint.rs:1790:42
     |
  14 | pub struct BigInt256 {
     | -------------------- method `unwrap` not found for this struct
...
1790 |         let b_mont = mont.convert_in(&b).unwrap();
     |                                          ^^^^^^ method not found in `math::bigint::BigInt256`

error[E0599]: no method named `unwrap` found for struct `math::bigint::BigInt256` in the current scope
    --> src/math/bigint.rs:1792:56
     |
  14 | pub struct BigInt256 {
     | -------------------- method `unwrap` not found for this struct
...
1792 |         let mont_result = mont.convert_out(&mont_prod).unwrap();
     |                                                        ^^^^^^ method not found in `math::bigint::BigInt256`

error[E0308]: mismatched types
   --> src/math/tests.rs:36:43
    |
 36 |         let reducer = BarrettReducer::new(&modulus).unwrap();
    |                       ------------------- ^^^^^^^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
    |                       |
    |                       arguments to this function are incorrect
    |
    = note: expected reference `&math::bigint::BigInt256`
               found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: associated function defined here
   --> src/math/bigint.rs:694:12
    |
694 |     pub fn new(modulus: &BigInt256) -> Self {
    |            ^^^ -------------------

error[E0599]: no method named `unwrap` found for struct `BarrettReducer` in the current scope
   --> src/math/tests.rs:36:53
    |
 36 |         let reducer = BarrettReducer::new(&modulus).unwrap();
    |                                                     ^^^^^^ method not found in `BarrettReducer`
    |
   ::: src/math/bigint.rs:682:1
    |
682 | pub struct BarrettReducer {
    | ------------------------- method `unwrap` not found for this struct

error[E0308]: mismatched types
  --> src/math/tests.rs:42:13
   |
42 |             BigInt256::from_hex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `BigInt256`, found `Result<BigInt256, String>`
   |
   = note: expected struct `math::bigint::BigInt256`
                found enum `std::result::Result<math::bigint::BigInt256, std::string::String>`
help: consider using `Result::expect` to unwrap the `std::result::Result<math::bigint::BigInt256, std::string::String>` value, panicking if the value is a `Result::Err`
   |
42 |             BigInt256::from_hex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF").expect("REASON"),
   |                                                                                                    +++++++++++++++++

error[E0425]: cannot find function `mod_inverse` in this scope
  --> src/math/tests.rs:87:19
   |
87 |         let inv = mod_inverse(&a, &modulus).unwrap();
   |                   ^^^^^^^^^^^ not found in this scope

error[E0599]: no method named `hash_position` found for struct `collision::CollisionDetector` in the current scope
   --> src/kangaroo/collision.rs:858:29
    |
 25 | pub struct CollisionDetector {
    | ---------------------------- method `hash_position` not found for this struct
...
858 |         let hash = detector.hash_position(&point);
    |                             ^^^^^^^^^^^^^ method not found in `collision::CollisionDetector`

error[E0061]: this method takes 6 arguments but 5 arguments were supplied
   --> src/kangaroo/collision.rs:872:31
    |
872 | ...ctor.walk_back_near_collision(&tame_trap, &wild_trap, &jump_table, &hash_fn, &range_width);
    |         ^^^^^^^^^^^^^^^^^^^^^^^^------------------------------------------------------------- argument #6 of type `&std::collections::HashMap<u32, f64>` is missing
    |
note: method defined here
   --> src/kangaroo/collision.rs:675:12
    |
675 | ...fn walk_back_near_collision(&self, t: &Trap, w: &Trap, jump_table: &[(BigUint, Point)], hash_fn: &impl Fn(&Point) -> usize, range_width: &BigInt256, _biases: &std::collections::HashMap<u32, f64>) -...
    |       ^^^^^^^^^^^^^^^^^^^^^^^^                                                                                                                          ---------------------------------------------
help: provide the argument
    |
872 |         let result = detector.walk_back_near_collision(&tame_trap, &wild_trap, &jump_table, &hash_fn, &range_width, /* &std::collections::HashMap<u32, f64> */);
    |                                                                                                                   ++++++++++++++++++++++++++++++++++++++++++++

error[E0616]: field `near_g_thresh` of struct `collision::CollisionDetector` is private
  --> src/kangaroo/tests.rs:42:29
   |
42 |         assert_eq!(detector.near_g_thresh, 1 << 18);
   |                             ^^^^^^^^^^^^^ private field

error[E0599]: no method named `mod_inverse_batch` found for struct `cpu_backend::CpuBackend` in the current scope
   --> src/gpu/backends/cpu_backend.rs:354:33
    |
 13 | pub struct CpuBackend;
    | --------------------- method `mod_inverse_batch` not found for this struct
...
354 |         let inv_batch = backend.mod_inverse_batch(&a, &modulus);
    |                                 ^^^^^^^^^^^^^^^^^ method not found in `cpu_backend::CpuBackend`

error[E0308]: mismatched types
   --> src/gpu/backends/cpu_backend.rs:358:46
    |
358 |         let reducer = MontgomeryReducer::new(&modulus);
    |                       ---------------------- ^^^^^^^^ expected `&BigInt256`, found `&Result<BigInt256, String>`
    |                       |
    |                       arguments to this function are incorrect
    |
    = note: expected reference `&math::bigint::BigInt256`
               found reference `&std::result::Result<math::bigint::BigInt256, std::string::String>`
note: associated function defined here
   --> src/math/bigint.rs:836:12
    |
836 |     pub fn new(modulus: &BigInt256) -> Self {
    |            ^^^ -------------------

error[E0615]: attempted to take value of method `len` on type `shared::SharedBuffer<u64>`
   --> src/gpu/shared.rs:113:27
    |
113 |         assert_eq!(buffer.len, 1024);
    |                           ^^^ method, not a field
    |
help: use parentheses to call the method
    |
113 |         assert_eq!(buffer.len(), 1024);
    |                              ++

error[E0061]: this function takes 7 arguments but 6 arguments were supplied
   --> src/dp/table.rs:949:25
    |
949 |             let state = KangarooState::new(point.clone(), i as u64, [0; 4], [0; 4], true, i as u64);
    |                         ^^^^^^^^^^^^^^^^^^                                                -------- argument #6 of type `bool` is missing
    |
note: associated function defined here
   --> src/types.rs:221:12
    |
221 | ...fn new(position: Point, distance: u64, alpha: [u64; 4], beta: [u64; 4], is_tame: bool, is_dp: bool, i...
    |       ^^^                                                                                 -----------
help: provide the argument
    |
949 |             let state = KangarooState::new(point.clone(), i as u64, [0; 4], [0; 4], true, /* bool */, i as u64);
    |                                                                                           +++++++++++

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> src/dp/pruning.rs:333:28
    |
333 |         let stats = pruner.prune_value_based().await.unwrap();
    |                            ^^^^^^^^^^^^^^^^^-- argument #1 of type `f64` is missing
    |
note: method defined here
   --> src/dp/pruning.rs:226:18
    |
226 |     pub async fn prune_value_based(&self, target_utilization: f64) -> Result<PruningStats> {
    |                  ^^^^^^^^^^^^^^^^^        -----------------------
help: provide the argument
    |
333 |         let stats = pruner.prune_value_based(/* f64 */).await.unwrap();
    |                                              +++++++++

error[E0609]: no field `entries_after` on type `pruning::PruningStats`
   --> src/dp/pruning.rs:335:23
    |
335 |         assert!(stats.entries_after < stats.entries_before);
    |                       ^^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `entries_removed`, `chunks_processed`, `duration_ms`, `additional_info`

error[E0609]: no field `entries_before` on type `pruning::PruningStats`
   --> src/dp/pruning.rs:335:45
    |
335 |         assert!(stats.entries_after < stats.entries_before);
    |                                             ^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
335 -         assert!(stats.entries_after < stats.entries_before);
335 +         assert!(stats.entries_after < stats.entries_removed);
    |

error[E0277]: `?` couldn't convert the error: `dyn StdError: Send` is not satisfied
  --> src/test_basic.rs:17:64
   |
12 |     fn test_g_times_3() -> Result<()> {
   |                            ---------- required `dyn StdError: Send` because of this
...
17 |         let three_g = curve.mul_constant_time(&three, &curve.g)?;
   |                             -----------------------------------^ `dyn StdError` cannot be sent between threads safely
   |                             |
   |                             this can't be annotated with `?` because it has type `Result<_, Box<(dyn StdError + 'static)>>`
   |
   = help: the trait `Send` is not implemented for `dyn StdError`
   = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
   = note: required for `Unique<dyn StdError>` to implement `Send`
note: required because it appears within the type `Box<dyn StdError>`
  --> /rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/alloc/src/boxed.rs:234:12
   = note: required for `anyhow::Error` to implement `From<Box<dyn StdError>>`

error[E0277]: `?` couldn't convert the error: `dyn StdError: Sync` is not satisfied
  --> src/test_basic.rs:17:64
   |
12 |     fn test_g_times_3() -> Result<()> {
   |                            ---------- required `dyn StdError: Sync` because of this
...
17 |         let three_g = curve.mul_constant_time(&three, &curve.g)?;
   |                             -----------------------------------^ `dyn StdError` cannot be shared between threads safely
   |                             |
   |                             this can't be annotated with `?` because it has type `Result<_, Box<(dyn StdError + 'static)>>`
   |
   = help: the trait `Sync` is not implemented for `dyn StdError`
   = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
   = note: required for `Unique<dyn StdError>` to implement `Sync`
note: required because it appears within the type `Box<dyn StdError>`
  --> /rustc/254b59607d4417e9dffbc307138ae5c86280fe4c/library/alloc/src/boxed.rs:234:12
   = note: required for `anyhow::Error` to implement `From<Box<dyn StdError>>`

error[E0277]: `?` couldn't convert the error: `dyn StdError: Sized` is not satisfied
  --> src/test_basic.rs:17:64
   |
12 |     fn test_g_times_3() -> Result<()> {
   |                            ---------- required `dyn StdError: Sized` because of this
...
17 |         let three_g = curve.mul_constant_time(&three, &curve.g)?;
   |                             -----------------------------------^ doesn't have a size known at compile-time
   |                             |
   |                             this can't be annotated with `?` because it has type `Result<_, Box<(dyn StdError + 'static)>>`
   |
   = help: the trait `Sized` is not implemented for `dyn StdError`
   = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
   = note: required for `Box<dyn StdError>` to implement `StdError`
   = note: required for `anyhow::Error` to implement `From<Box<dyn StdError>>`

error[E0624]: method `glv_decompose` is private
   --> src/test_basic.rs:45:30
    |
 45 |         let (k1, k2) = curve.glv_decompose(&k);
    |                              ^^^^^^^^^^^^^ private method
    |
   ::: src/math/secp.rs:587:5
    |
587 |     fn glv_decompose(&self, k: &BigInt256) -> (BigInt256, BigInt256) {
    |     ---------------------------------------------------------------- private method defined here

error[E0282]: type annotations needed
  --> src/test_basic.rs:48:17
   |
48 |         assert!(k1.bits() <= 128,
   |                 ^^ cannot infer type

error[E0282]: type annotations needed
  --> src/test_basic.rs:50:17
   |
50 |         assert!(k2.bits() <= 128,
   |                 ^^ cannot infer type

error[E0277]: the `?` operator can only be applied to values that implement `Try`
   --> src/test_basic.rs:219:22
    |
219 |         let points = load_test_puzzles("valuable_p2pk_pubkeys.txt", &curve)?;
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `Vec<types::Point>`
    |
    = help: the trait `Try` is not implemented for `Vec<types::Point>`

error[E0282]: type annotations needed
   --> src/test_basic.rs:219:13
    |
219 |         let points = load_test_puzzles("valuable_p2pk_pubkeys.txt", &curve)?;
    |             ^^^^^^
220 |         assert!(!points.is_empty(), "Should load at least test puzzles");
    |                  ------ type must be known at this point
    |
help: consider giving `points` an explicit type
    |
219 |         let points: /* Type */ = load_test_puzzles("valuable_p2pk_pubkeys.txt", &curve)?;
    |                   ++++++++++++

warning: unused import: `Mul`
 --> src/kangaroo/collision.rs:7:21
  |
7 | use std::ops::{Sub, Mul};
  |                     ^^^

warning: unused import: `Sub`
 --> src/kangaroo/collision.rs:7:16
  |
7 | use std::ops::{Sub, Mul};
  |                ^^^

warning: variable does not need to be mutable
   --> src/math/secp.rs:150:13
    |
150 |         let mut temp_curve = Secp256k1 {
    |             ----^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `gid`
   --> src/kangaroo/manager.rs:793:18
    |
793 |             for (gid, group_states) in &mut groups {
    |                  ^^^ help: if this is intentional, prefix it with an underscore: `_gid`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `detector`
  --> src/kangaroo/tests.rs:13:13
   |
13 |         let detector = CollisionDetector::new_with_config(&config);
   |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_detector`

warning: unused variable: `trap_near_g`
  --> src/kangaroo/tests.rs:25:13
   |
25 |         let trap_near_g = Trap {
   |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_trap_near_g`

warning: unused variable: `range_width`
  --> src/kangaroo/tests.rs:31:13
   |
31 |         let range_width = BigInt256::from_u64(1 << 20); // Small range for testing
   |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_range_width`

warning: value assigned to `all_traps` is never read
   --> src/gpu/backends/hybrid_backend.rs:189:29
    |
189 |         let mut all_traps = Vec::new();
    |                             ^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
   --> src/dp/table.rs:694:13
    |
694 |         let mut table = DpTable::with_disk_support(4, true, Some(db_path.clone()));
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `contents`
   --> src/puzzles.rs:105:13
    |
105 |         let contents = contents_ascii;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_contents`

Some errors have detailed explanations: E0061, E0277, E0282, E0308, E0369, E0425, E0599, E0609, E0615...
For more information about an error, try `rustc --explain E0061`.
warning: `speedbitcrack` (lib test) generated 34 warnings
warning: speedbitcrack@0.1.0: Successfully opened valuable_p2pk_pubkeys.txt for bias computation
error: could not compile `speedbitcrack` (lib test) due to 77 previous errors; 34 warnings emitted
