   Compiling speedbitcrack v0.1.0 (/data/Projects/SpeedBitCrackV3)
error[E0106]: missing lifetime specifier
  --> src/gpu/backends/cuda_backend.rs:16:51
   |
16 |     kernels: HashMap<String, rustacuda::function::Function>,
   |                                                   ^^^^^^^^ expected named lifetime parameter
   |
help: consider introducing a named lifetime parameter
   |
13 ~ pub struct CudaBackend<'a> {
14 |     context: rustacuda::context::Context,
15 |     stream: rustacuda::stream::Stream,
16 ~     kernels: HashMap<String, rustacuda::function::Function<'a>>,
   |

error[E0106]: missing lifetime specifier
  --> src/gpu/backends/cuda_backend.rs:24:74
   |
24 |     pub fn load_kernels() -> Result<HashMap<String, rustacuda::function::Function>> {
   |                                                                          ^^^^^^^^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`, or if you will only have owned values
   |
24 |     pub fn load_kernels() -> Result<HashMap<String, rustacuda::function::Function<'static>>> {
   |                                                                                  +++++++++

error[E0425]: cannot find type `HashMap` in this scope
  --> src/gpu/backends/cuda_backend.rs:16:14
   |
16 |     kernels: HashMap<String, rustacuda::function::Function>,
   |              ^^^^^^^ not found in this scope
   |
help: consider importing this struct
   |
 6 + use std::collections::HashMap;
   |

error[E0425]: cannot find type `HashMap` in this scope
  --> src/gpu/backends/cuda_backend.rs:24:37
   |
24 |     pub fn load_kernels() -> Result<HashMap<String, rustacuda::function::Function>> {
   |                                     ^^^^^^^ not found in this scope
   |
help: consider importing this struct
   |
 6 + use std::collections::HashMap;
   |

error[E0433]: failed to resolve: use of undeclared type `HashMap`
  --> src/gpu/backends/cuda_backend.rs:25:27
   |
25 |         let mut kernels = HashMap::new();
   |                           ^^^^^^^ use of undeclared type `HashMap`
   |
help: consider importing this struct
   |
 6 + use std::collections::HashMap;
   |

error[E0425]: cannot find value `fail` in this scope
   --> src/gpu/backends/hybrid_backend.rs:886:42
    |
882 |     fn simulate_cuda_fail(&mut self, _fail: bool) {
    |                                      ----- `_fail` defined here
...
886 |             self.cuda.simulate_cuda_fail(fail);
    |                                          ^^^^
    |
help: the leading underscore in `_fail` marks it as unused, consider renaming it to `fail`
    |
882 -     fn simulate_cuda_fail(&mut self, _fail: bool) {
882 +     fn simulate_cuda_fail(&mut self, fail: bool) {
    |

error[E0425]: cannot find value `batch_steps` in this scope
    --> src/gpu/backends/hybrid_backend.rs:1140:17
     |
1109 |                                _range: (BigInt256, BigInt256), _batch_steps: u64)
     |                                                                ------------ `_batch_steps` defined here
...
1140 |                 batch_steps as u32
     |                 ^^^^^^^^^^^
     |
help: the leading underscore in `_batch_steps` marks it as unused, consider renaming it to `batch_steps`
     |
1109 -                                _range: (BigInt256, BigInt256), _batch_steps: u64)
1109 +                                _range: (BigInt256, BigInt256), batch_steps: u64)
     |

error[E0425]: cannot find type `CudaSlice` in this scope
    --> src/gpu/backends/hybrid_backend.rs:1186:56
     |
1186 |     pub async fn prefetch_states_batch(&self, states: &CudaSlice<RhoState>,
     |                                                        ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `num_walks` in this scope
   --> src/gpu/hybrid_manager.rs:332:53
    |
312 | ...rents_rho(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
    |                                           ---------- `_num_walks` defined here
...
332 | ... = Vec::with_capacity(num_walks);
    |                          ^^^^^^^^^
    |
help: the leading underscore in `_num_walks` marks it as unused, consider renaming it to `num_walks`
    |
312 -     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
312 +     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
    |

error[E0425]: cannot find value `num_walks` in this scope
   --> src/gpu/hybrid_manager.rs:333:25
    |
312 | ...tch_parallel_brents_rho(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Option...
    |                                                         ---------- `_num_walks` defined here
...
333 | ...i in 0..num_walks {
    |            ^^^^^^^^^
    |
help: the leading underscore in `_num_walks` marks it as unused, consider renaming it to `num_walks`
    |
312 -     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
312 +     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
    |

error[E0425]: cannot find value `p` in this scope
   --> src/gpu/hybrid_manager.rs:335:30
    |
312 |     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u...
    |                                                           -- `_p` defined here
...
335 |                     current: p.clone(),  // Start from target point
    |                              ^
    |
help: the leading underscore in `_p` marks it as unused, consider renaming it to `p`
    |
312 -     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
312 +     pub fn dispatch_parallel_brents_rho(&self, _g: Point, p: Point, _num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
    |

error[E0425]: cannot find value `bias_mod` in this scope
   --> src/gpu/hybrid_manager.rs:337:21
    |
312 | ...spatch_parallel_brents_rho(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Opt...
    |                                                                               --------- `_bias_mod` defined here
...
337 | ...       bias_mod,
    |           ^^^^^^^^
    |
help: the leading underscore in `_bias_mod` marks it as unused, consider renaming it to `bias_mod`
    |
312 -     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
312 +     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, _num_walks: usize, bias_mod: u64) -> Option<BigInt256> {
    |

error[E0425]: cannot find value `num_walks` in this scope
   --> src/gpu/hybrid_manager.rs:344:66
    |
312 | ...ho(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
    |                                    ---------- `_num_walks` defined here
...
344 | ...aunch_rho_kernel(&d_states, num_walks as u32, BigInt256::from_u64(bias_mod)).is_ok() {
    |                                ^^^^^^^^^
    |
help: the leading underscore in `_num_walks` marks it as unused, consider renaming it to `num_walks`
    |
312 -     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
312 +     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
    |

error[E0425]: cannot find value `bias_mod` in this scope
   --> src/gpu/hybrid_manager.rs:344:104
    |
312 | ... _p: Point, _num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
    |                                   --------- `_bias_mod` defined here
...
344 | ...states, num_walks as u32, BigInt256::from_u64(bias_mod)).is_ok() {
    |                                                  ^^^^^^^^
    |
help: the leading underscore in `_bias_mod` marks it as unused, consider renaming it to `bias_mod`
    |
312 -     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Option<BigInt256> {
312 +     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, _num_walks: usize, bias_mod: u64) -> Option<BigInt256> {
    |

error[E0425]: cannot find type `DpPoint` in module `crate::gpu::backends::cuda_backend`
   --> src/gpu/hybrid_manager.rs:373:72
    |
373 |     fn check_collision(&self, dp: &crate::gpu::backends::cuda_backend::DpPoint) -> Option<BigInt256> {
    |                                                                        ^^^^^^^ not found in `crate::gpu::backends::cuda_backend`

error[E0425]: cannot find value `num_walks` in this scope
   --> src/gpu/hybrid_manager.rs:446:53
    |
436 | ...rents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Result<Option<...
    |                                                 ---------- `_num_walks` defined here
...
446 | ...::with_capacity(num_walks);
    |                    ^^^^^^^^^
    |
help: the leading underscore in `_num_walks` marks it as unused, consider renaming it to `num_walks`
    |
436 -     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
436 +     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, num_walks: usize, _bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
    |

error[E0425]: cannot find value `num_walks` in this scope
   --> src/gpu/hybrid_manager.rs:447:25
    |
436 | ... fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod:...
    |                                                                        ---------- `_num_walks` defined here
...
447 | ...or i in 0..num_walks {
    |               ^^^^^^^^^
    |
help: the leading underscore in `_num_walks` marks it as unused, consider renaming it to `num_walks`
    |
436 -     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
436 +     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, num_walks: usize, _bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
    |

error[E0425]: cannot find value `p` in this scope
   --> src/gpu/hybrid_manager.rs:449:30
    |
436 |     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, ...
    |                                                                       -- `_p` defined here
...
449 |                     current: p.clone(),  // Start from target point
    |                              ^
    |
help: the leading underscore in `_p` marks it as unused, consider renaming it to `p`
    |
436 -     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
436 +     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, p: Point, _num_walks: usize, _bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
    |

error[E0425]: cannot find value `bias_mod` in this scope
   --> src/gpu/hybrid_manager.rs:451:21
    |
436 | ...dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64...
    |                                                                                       --------- `_bias_mod` defined here
...
451 | ...   bias_mod,
    |       ^^^^^^^^
    |
help: the leading underscore in `_bias_mod` marks it as unused, consider renaming it to `bias_mod`
    |
436 -     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
436 +     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
    |

error[E0425]: cannot find value `num_walks` in this scope
   --> src/gpu/hybrid_manager.rs:459:55
    |
436 | ...ents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Result<Option<B...
    |                                                ---------- `_num_walks` defined here
...
459 | ...ernel(&d_states, num_walks as u32, BigInt256::from_u64(bias_mod))
    |                     ^^^^^^^^^
    |
help: the leading underscore in `_num_walks` marks it as unused, consider renaming it to `num_walks`
    |
436 -     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
436 +     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, num_walks: usize, _bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
    |

error[E0425]: cannot find value `bias_mod` in this scope
   --> src/gpu/hybrid_manager.rs:459:93
    |
436 | ...int, _p: Point, _num_walks: usize, _bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
    |                                       --------- `_bias_mod` defined here
...
459 | ...s u32, BigInt256::from_u64(bias_mod))
    |                               ^^^^^^^^
    |
help: the leading underscore in `_bias_mod` marks it as unused, consider renaming it to `bias_mod`
    |
436 -     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
436 +     pub async fn dispatch_parallel_brents_rho_async(&self, _g: Point, _p: Point, _num_walks: usize, bias_mod: u64) -> Result<Option<BigInt256>, anyhow::Error> {
    |

error[E0603]: struct import `Point` is private
   --> src/gpu/hybrid_manager.rs:504:40
    |
504 |                     crate::math::secp::Point::infinity(), // placeholder
    |                                        ^^^^^ private struct import
    |
note: the struct import `Point` is defined here...
   --> src/math/secp.rs:9:5
    |
  9 | use crate::types::Point;
    |     ^^^^^^^^^^^^^^^^^^^
note: ...and refers to the struct `Point` which is defined here
   --> src/types.rs:131:1
    |
131 | pub struct Point {
    | ^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
504 -                     crate::math::secp::Point::infinity(), // placeholder
504 +                     crate::Point::infinity(), // placeholder
    |
help: import `Point` directly
    |
504 -                     crate::math::secp::Point::infinity(), // placeholder
504 +                     types::Point(), // placeholder
    |

error[E0603]: struct import `Point` is private
   --> src/gpu/hybrid_manager.rs:505:40
    |
505 |                     crate::math::secp::Point::infinity(),
    |                                        ^^^^^ private struct import
    |
note: the struct import `Point` is defined here...
   --> src/math/secp.rs:9:5
    |
  9 | use crate::types::Point;
    |     ^^^^^^^^^^^^^^^^^^^
note: ...and refers to the struct `Point` which is defined here
   --> src/types.rs:131:1
    |
131 | pub struct Point {
    | ^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
505 -                     crate::math::secp::Point::infinity(),
505 +                     crate::Point::infinity(),
    |
help: import `Point` directly
    |
505 -                     crate::math::secp::Point::infinity(),
505 +                     types::Point(),
    |

error: usage of an `unsafe` block
   --> src/gpu/backends/cuda_backend.rs:193:29
    |
193 | ..._scalars = unsafe { rustacuda::memory::DeviceBuffer::uninitialized(batch_size * 32)? };
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: the lint level is defined here
   --> src/lib.rs:15:9
    |
 15 | #![deny(unsafe_code)]
    |         ^^^^^^^^^^^

error: usage of an `unsafe` block
   --> src/gpu/backends/cuda_backend.rs:194:29
    |
194 |         let mut d_results = unsafe { rustacuda::memory::DeviceBuffer::uninitialized(output_size)? };
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: usage of an `unsafe` block
   --> src/gpu/backends/cuda_backend.rs:197:36
    |
197 |           let scalars_bytes: &[u8] = unsafe {
    |  ____________________________________^
198 | |             std::slice::from_raw_parts(scalars.as_ptr() as *const u8, scalars.len() * 32)
199 | |         };
    | |_________^

error: usage of an `unsafe` block
   --> src/gpu/backends/cuda_backend.rs:206:9
    |
206 | /         unsafe {
207 | |             kernel.launch(
208 | |                 &[&d_scalars, &d_results, &batch_size as *const i32],
209 | |                 grid_size as u32, block_size, 0, &self.stream
210 | |             )?;
211 | |         }
    | |_________^

warning: unused import: `crate::math::secp::Secp256k1`
 --> src/gpu/backends/vulkan_backend.rs:8:5
  |
8 | use crate::math::secp::Secp256k1;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Point`
 --> src/gpu/backends/vulkan_backend.rs:9:20
  |
9 | use crate::types::{Point, DpEntry};
  |                    ^^^^^

warning: unused import: `rand::Rng`
  --> src/gpu/backends/vulkan_backend.rs:11:5
   |
11 | use rand::Rng;
   |     ^^^^^^^^^

warning: unused import: `crate::math::bigint::BigInt256`
   --> src/gpu/backends/vulkan_backend.rs:187:13
    |
187 |         use crate::math::bigint::BigInt256;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0382]: borrow of moved value: `cuda_result`
   --> src/gpu/backends/hybrid_backend.rs:81:30
    |
 77 |         let cuda_result = CudaBackend::new();
    |             ----------- move occurs because `cuda_result` has type `std::result::Result<CudaBackend, anyhow::Error>`, which does not implement the `Copy` trait
 78 |         #[cfg(feature = "rustacuda")]
 79 |         let cuda = cuda_result?;
    |                    ------------ `cuda_result` moved due to this method call
 80 |         #[cfg(feature = "rustacuda")]
 81 |         let cuda_available = cuda_result.is_ok();
    |                              ^^^^^^^^^^^ value borrowed here after move
    |
note: `branch` takes ownership of the receiver `self`, which moves `cuda_result`
   --> /home/curtlarson/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/try_trait.rs:219:15
    |
219 |     fn branch(self) -> ControlFlow<Self::Residual, Self::Output>;
    |               ^^^^
help: you could `clone` the value and consume it, if the following trait bounds could be satisfied: `CudaBackend: Clone` and `anyhow::Error: Clone`
    |
 79 |         let cuda = cuda_result.clone()?;
    |                               ++++++++

error[E0308]: arguments to this method are incorrect
   --> src/gpu/backends/hybrid_backend.rs:198:27
    |
198 |                 self.cuda.step_batch(cuda_batch, jumps, config).await
    |                           ^^^^^^^^^^
    |
note: types differ in mutability
   --> src/gpu/backends/hybrid_backend.rs:198:38
    |
198 |                 self.cuda.step_batch(cuda_batch, jumps, config).await
    |                                      ^^^^^^^^^^
    = note: expected mutable reference `&mut Vec<[[u32; 8]; 3]>`
                       found reference `&[KangarooState]`
note: types differ in mutability
   --> src/gpu/backends/hybrid_backend.rs:198:50
    |
198 |                 self.cuda.step_batch(cuda_batch, jumps, config).await
    |                                                  ^^^^^
    = note: expected mutable reference `&mut Vec<[u32; 8]>`
                       found reference `&[BigInt256]`
note: expected `&Vec<u32>`, found `&Config`
   --> src/gpu/backends/hybrid_backend.rs:198:57
    |
198 |                 self.cuda.step_batch(cuda_batch, jumps, config).await
    |                                                         ^^^^^^
    = note: expected reference `&Vec<u32>`
               found reference `&config::Config`
note: method defined here
   --> src/gpu/backends/backend_trait.rs:36:8
    |
 36 |     fn step_batch(&self, positions: &mut Vec<[[u32;8];3]>, distances: &mut Vec<[u32;8]>, types: &Vec...
    |        ^^^^^^^^^^        ---------                         ---------                     -----

error[E0277]: `std::result::Result<Vec<Trap>, anyhow::Error>` is not a future
   --> src/gpu/backends/hybrid_backend.rs:198:65
    |
198 |                 self.cuda.step_batch(cuda_batch, jumps, config).await
    |                                                                 ^^^^^ `std::result::Result<Vec<Trap>, anyhow::Error>` is not a future
    |
    = help: the trait `Future` is not implemented for `std::result::Result<Vec<Trap>, anyhow::Error>`
    = note: std::result::Result<Vec<Trap>, anyhow::Error> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `std::result::Result<Vec<Trap>, anyhow::Error>` to implement `IntoFuture`
help: remove the `.await`
    |
198 -                 self.cuda.step_batch(cuda_batch, jumps, config).await
198 +                 self.cuda.step_batch(cuda_batch, jumps, config)
    |

error[E0599]: no function or associated item named `synchronize` found for struct `rustacuda::device::Device` in the current scope
   --> src/gpu/backends/hybrid_backend.rs:279:68
    |
279 | ...                   rustacuda::device::Device::synchronize()?;
    |                                                  ^^^^^^^^^^^ function or associated item not found in `rustacuda::device::Device`
    |
note: if you're trying to build a new `rustacuda::device::Device`, consider using `rustacuda::device::Device::get_device` which returns `std::result::Result<rustacuda::device::Device, CudaError>`
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/device.rs:246:5
    |
246 |     pub fn get_device(ordinal: u32) -> CudaResult<Device> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `step_batch_unified` found for struct `CudaBackend` in the current scope
   --> src/gpu/backends/hybrid_backend.rs:281:57
    |
281 | ...                   match self.cuda.step_batch_unified(
    |                             ----------^^^^^^^^^^^^^^^^^^
    |
   ::: src/gpu/backends/cuda_backend.rs:13:1
    |
 13 | pub struct CudaBackend {
    | ---------------------- method `step_batch_unified` not found for this struct
    |
help: there is a method `step_batch` with a similar name, but with different arguments
   --> src/gpu/backends/backend_trait.rs:36:5
    |
 36 |     fn step_batch(&self, positions: &mut Vec<[[u32;8];3]>, distances: &mut Vec<[u32;8]>, types: &Vec<u32>) -> Result<Vec<Trap>>;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `as_device_ptr` found for struct `UnifiedBuffer<[[u32; 8]; 3]>` in the current scope
   --> src/gpu/backends/hybrid_backend.rs:282:63
    |
282 | ...                   unified_positions.as_device_ptr(),
    |                                         ^^^^^^^^^^^^^ method not found in `UnifiedBuffer<[[u32; 8]; 3]>`

error[E0599]: no method named `as_device_ptr` found for struct `UnifiedBuffer<[u32; 8]>` in the current scope
   --> src/gpu/backends/hybrid_backend.rs:283:63
    |
283 | ...                   unified_distances.as_device_ptr(),
    |                                         ^^^^^^^^^^^^^ method not found in `UnifiedBuffer<[u32; 8]>`

error[E0599]: no method named `as_device_ptr` found for struct `UnifiedBuffer<u32>` in the current scope
   --> src/gpu/backends/hybrid_backend.rs:284:59
    |
284 | ...                   unified_types.as_device_ptr(),
    |                                     ^^^^^^^^^^^^^ method not found in `UnifiedBuffer<u32>`

error[E0599]: no method named `device` found for struct `CudaBackend` in the current scope
    --> src/gpu/backends/hybrid_backend.rs:1116:31
     |
1116 |             let device = cuda.device()?;
     |                               ^^^^^^ method not found in `CudaBackend`
     |
    ::: src/gpu/backends/cuda_backend.rs:13:1
     |
  13 | pub struct CudaBackend {
     | ---------------------- method `device` not found for this struct

error[E0599]: no method named `alloc_and_copy_pinned_async` found for struct `CudaBackend` in the current scope
    --> src/gpu/backends/hybrid_backend.rs:1123:35
     |
1123 |             let mut states = cuda.alloc_and_copy_pinned_async(&vec![RhoState::default(); 1000],
     |                              -----^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `CudaBackend`
     |
    ::: src/gpu/backends/cuda_backend.rs:13:1
     |
  13 | pub struct CudaBackend {
     | ---------------------- method `alloc_and_copy_pinned_async` not found for this struct

error[E0282]: type annotations needed
    --> src/gpu/backends/hybrid_backend.rs:1123:17
     |
1123 |             let mut states = cuda.alloc_and_copy_pinned_async(&vec![RhoState::default(); 1000],
     |                 ^^^^^^^^^^
...
1128 |                 states.as_ptr() as *const std::ffi::c_void,
     |                 ------ type must be known at this point
     |
help: consider giving `states` an explicit type
     |
1123 |             let mut states: /* Type */ = cuda.alloc_and_copy_pinned_async(&vec![RhoState::default(); 1000],
     |                           ++++++++++++

error[E0599]: no method named `dispatch_async` found for struct `CudaBackend` in the current scope
    --> src/gpu/backends/hybrid_backend.rs:1135:38
     |
1135 |             let compute_event = cuda.dispatch_async(
     |                                 -----^^^^^^^^^^^^^^ method not found in `CudaBackend`
     |
    ::: src/gpu/backends/cuda_backend.rs:13:1
     |
  13 | pub struct CudaBackend {
     | ---------------------- method `dispatch_async` not found for this struct

error[E0282]: type annotations needed
    --> src/gpu/backends/hybrid_backend.rs:1135:17
     |
1135 |             let compute_event = cuda.dispatch_async(
     |                 ^^^^^^^^^^^^^
...
1147 |             compute_event.synchronize()?;
     |             ------------- type must be known at this point
     |
help: consider giving `compute_event` an explicit type
     |
1135 |             let compute_event: /* Type */ = cuda.dispatch_async(
     |                              ++++++++++++

error[E0609]: no field `dp_table` on type `&hybrid_backend::HybridBackend`
    --> src/gpu/backends/hybrid_backend.rs:1150:72
     |
1150 |             if let Some(key) = self.check_and_resolve_collisions(&self.dp_table, &host_states).await {
     |                                                                        ^^^^^^^^ unknown field
     |
     = note: available fields are: `vulkan`, `cuda`, `cpu`, `cuda_available`

error[E0599]: no method named `prefetch_batch` found for struct `CudaBackend` in the current scope
    --> src/gpu/backends/hybrid_backend.rs:1192:14
     |
1192 |         cuda.prefetch_batch(states, batch_start, batch_size).await?;
     |              ^^^^^^^^^^^^^^ method not found in `CudaBackend`
     |
    ::: src/gpu/backends/cuda_backend.rs:13:1
     |
  13 | pub struct CudaBackend {
     | ---------------------- method `prefetch_batch` not found for this struct

error[E0599]: no method named `device` found for struct `CudaBackend` in the current scope
    --> src/gpu/backends/hybrid_backend.rs:1203:27
     |
1203 |         let device = cuda.device()?;
     |                           ^^^^^^ method not found in `CudaBackend`
     |
    ::: src/gpu/backends/cuda_backend.rs:13:1
     |
  13 | pub struct CudaBackend {
     | ---------------------- method `device` not found for this struct

error[E0560]: struct `RhoState` has no field named `bias_mod`
   --> src/gpu/hybrid_manager.rs:451:21
    |
451 |                     bias_mod,
    |                     ^^^^^^^^ `RhoState` does not have this field
    |
    = note: available fields are: `is_dp`

error[E0599]: no method named `create_state_buffer` found for struct `CudaBackend` in the current scope
   --> src/gpu/hybrid_manager.rs:456:41
    |
456 |             let d_states = cuda_backend.create_state_buffer(&rho_states)
    |                                         ^^^^^^^^^^^^^^^^^^^ method not found in `CudaBackend`
    |
   ::: src/gpu/backends/cuda_backend.rs:13:1
    |
 13 | pub struct CudaBackend {
    | ---------------------- method `create_state_buffer` not found for this struct

error[E0599]: no method named `launch_rho_kernel` found for struct `CudaBackend` in the current scope
   --> src/gpu/hybrid_manager.rs:459:26
    |
459 |             cuda_backend.launch_rho_kernel(&d_states, num_walks as u32, BigInt256::from_u64(bias_mod))
    |                          ^^^^^^^^^^^^^^^^^ method not found in `CudaBackend`
    |
   ::: src/gpu/backends/cuda_backend.rs:13:1
    |
 13 | pub struct CudaBackend {
    | ---------------------- method `launch_rho_kernel` not found for this struct

error[E0599]: no method named `read_dp_buffer` found for struct `CudaBackend` in the current scope
   --> src/gpu/hybrid_manager.rs:463:42
    |
463 |             let dp_points = cuda_backend.read_dp_buffer()
    |                                          ^^^^^^^^^^^^^^ method not found in `CudaBackend`
    |
   ::: src/gpu/backends/cuda_backend.rs:13:1
    |
 13 | pub struct CudaBackend {
    | ---------------------- method `read_dp_buffer` not found for this struct

error[E0308]: mismatched types
  --> src/gpu/backends/cuda_backend.rs:31:57
   |
31 |         match rustacuda::module::Module::load_from_file("gpu/cuda/glv_decomp.ptx") {
   |               ----------------------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
   |               |
   |               arguments to this function are incorrect
   |
   = note: expected reference `&CStr`
              found reference `&'static str`
note: associated function defined here
  --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:39:12
   |
39 |     pub fn load_from_file(filename: &CStr) -> CudaResult<Module> {
   |            ^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:33:59
    |
 33 |                 if let Ok(func) = glv_module.get_function("glv4_batch_decompose_kernel") {
    |                                              ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                              |
    |                                              arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:36:59
    |
 36 |                 if let Ok(func) = glv_module.get_function("glv6_batch_decompose_kernel") {
    |                                              ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                              |
    |                                              arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:39:59
    |
 39 |                 if let Ok(func) = glv_module.get_function("glv8_batch_decompose_kernel") {
    |                                              ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                              |
    |                                              arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/gpu/backends/cuda_backend.rs:50:57
   |
50 |         match rustacuda::module::Module::load_from_file("gpu/cuda/step.ptx") {
   |               ----------------------------------------- ^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
   |               |
   |               arguments to this function are incorrect
   |
   = note: expected reference `&CStr`
              found reference `&'static str`
note: associated function defined here
  --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:39:12
   |
39 |     pub fn load_from_file(filename: &CStr) -> CudaResult<Module> {
   |            ^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:53:60
    |
 53 |                 if let Ok(func) = step_module.get_function("step_kernel") {
    |                                               ------------ ^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                               |
    |                                               arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/gpu/backends/cuda_backend.rs:63:57
   |
63 |         match rustacuda::module::Module::load_from_file("gpu/cuda/solve.ptx") {
   |               ----------------------------------------- ^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
   |               |
   |               arguments to this function are incorrect
   |
   = note: expected reference `&CStr`
              found reference `&'static str`
note: associated function defined here
  --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:39:12
   |
39 |     pub fn load_from_file(filename: &CStr) -> CudaResult<Module> {
   |            ^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:65:61
    |
 65 |                 if let Ok(func) = solve_module.get_function("bsgs_solve_kernel") {
    |                                                ------------ ^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                                |
    |                                                arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/gpu/backends/cuda_backend.rs:75:57
   |
75 |         match rustacuda::module::Module::load_from_file("gpu/cuda/wnaf_tables.ptx") {
   |               ----------------------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
   |               |
   |               arguments to this function are incorrect
   |
   = note: expected reference `&CStr`
              found reference `&'static str`
note: associated function defined here
  --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:39:12
   |
39 |     pub fn load_from_file(filename: &CStr) -> CudaResult<Module> {
   |            ^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:77:60
    |
 77 |                 if let Ok(func) = wnaf_module.get_function("precompute_wnaf_table_kernel") {
    |                                               ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                               |
    |                                               arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:80:60
    |
 80 |                 if let Ok(func) = wnaf_module.get_function("batch_wnaf_scalar_mul_kernel") {
    |                                               ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                               |
    |                                               arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
  --> src/gpu/backends/cuda_backend.rs:90:57
   |
90 |         match rustacuda::module::Module::load_from_file("gpu/cuda/texture_jump_kernel.ptx") {
   |               ----------------------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
   |               |
   |               arguments to this function are incorrect
   |
   = note: expected reference `&CStr`
              found reference `&'static str`
note: associated function defined here
  --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:39:12
   |
39 |     pub fn load_from_file(filename: &CStr) -> CudaResult<Module> {
   |            ^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:92:63
    |
 92 |                 if let Ok(func) = texture_module.get_function("rho_kernel_texture_jumps") {
    |                                                  ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                                  |
    |                                                  arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:102:57
    |
102 |         match rustacuda::module::Module::load_from_file("gpu/cuda/system_optimizations.ptx") {
    |               ----------------------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |               |
    |               arguments to this function are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: associated function defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:39:12
    |
 39 |     pub fn load_from_file(filename: &CStr) -> CudaResult<Module> {
    |            ^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:104:59
    |
104 |                 if let Ok(func) = sys_module.get_function("dynamic_parallelism_dispatch_kernel") {
    |                                              ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                              |
    |                                              arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:107:59
    |
107 |                 if let Ok(func) = sys_module.get_function("error_recovery_kernel") {
    |                                              ------------ ^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                              |
    |                                              arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:117:57
    |
117 |         match rustacuda::module::Module::load_from_file("gpu/cuda/brent_cycle_detection.ptx") {
    |               ----------------------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |               |
    |               arguments to this function are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: associated function defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:39:12
    |
 39 |     pub fn load_from_file(filename: &CStr) -> CudaResult<Module> {
    |            ^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:119:61
    |
119 |                 if let Ok(func) = brent_module.get_function("brent_cycle_detection_kernel") {
    |                                                ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                                |
    |                                                arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:122:61
    |
122 |                 if let Ok(func) = brent_module.get_function("meet_in_middle_bsgs_kernel") {
    |                                                ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                                |
    |                                                arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:132:57
    |
132 |         match rustacuda::module::Module::load_from_file("gpu/cuda/adaptive_tuning.ptx") {
    |               ----------------------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |               |
    |               arguments to this function are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: associated function defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:39:12
    |
 39 |     pub fn load_from_file(filename: &CStr) -> CudaResult<Module> {
    |            ^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:134:64
    |
134 |                 if let Ok(func) = adaptive_module.get_function("adaptive_parameter_tuning_kernel") {
    |                                                   ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                                   |
    |                                                   arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:137:64
    |
137 |                 if let Ok(func) = adaptive_module.get_function("parallel_collision_search_kernel") {
    |                                                   ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                                   |
    |                                                   arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:140:64
    |
140 |                 if let Ok(func) = adaptive_module.get_function("l2_cache_prefetch_kernel") {
    |                                                   ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&CStr`, found `&str`
    |                                                   |
    |                                                   arguments to this method are incorrect
    |
    = note: expected reference `&CStr`
               found reference `&'static str`
note: method defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/module.rs:153:12
    |
153 |     pub fn get_function<'a>(&'a self, name: &CStr) -> CudaResult<Function<'a>> {
    |            ^^^^^^^^^^^^

error[E0599]: no method named `copy_from_slice` found for struct `DeviceBuffer<_>` in the current scope
   --> src/gpu/backends/cuda_backend.rs:200:19
    |
200 |         d_scalars.copy_from_slice(scalars_bytes)?;
    |                   ^^^^^^^^^^^^^^^
    |
help: there is a method `copy_from` with a similar name
    |
200 -         d_scalars.copy_from_slice(scalars_bytes)?;
200 +         d_scalars.copy_from(scalars_bytes)?;
    |

error[E0308]: mismatched types
   --> src/gpu/backends/cuda_backend.rs:208:43
    |
208 |                 &[&d_scalars, &d_results, &batch_size as *const i32],
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&DeviceBuffer<_>`, found `*const i32`
    |
    = note: expected reference `&DeviceBuffer<_>`
             found raw pointer `*const i32`

error[E0599]: no method named `copy_to_slice` found for struct `DeviceBuffer<_>` in the current scope
   --> src/gpu/backends/cuda_backend.rs:215:19
    |
215 |         d_results.copy_to_slice(&mut results_bytes)?;
    |                   ^^^^^^^^^^^^^
    |
help: there is a method `copy_to` with a similar name
    |
215 -         d_results.copy_to_slice(&mut results_bytes)?;
215 +         d_results.copy_to(&mut results_bytes)?;
    |

error[E0606]: casting `&usize` as `*const i32` is invalid
   --> src/gpu/backends/cuda_backend.rs:208:43
    |
208 |                 &[&d_scalars, &d_results, &batch_size as *const i32],
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src/gpu/backends/hybrid_backend.rs:443:26
    |
443 |         let mut buffer = UnifiedBuffer::new(data.len())?;
    |                          ^^^^^^^^^^^^^^^^^^ ---------- argument #1 of type `&_` is missing
    |
note: associated function defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/memory/unified.rs:350:12
    |
350 |     pub fn new(value: &T, size: usize) -> CudaResult<Self> {
    |            ^^^
help: provide the argument
    |
443 |         let mut buffer = UnifiedBuffer::new(/* value */, data.len())?;
    |                                             ++++++++++++

error[E0599]: no method named `copy_from` found for struct `UnifiedBuffer<_>` in the current scope
   --> src/gpu/backends/hybrid_backend.rs:444:16
    |
444 |         buffer.copy_from(data)?;
    |                ^^^^^^^^^
    |
help: there is a method `copy_from_slice` with a similar name
    |
444 |         buffer.copy_from_slice(data)?;
    |                         ++++++

error[E0277]: the trait bound `T: Clone` is not satisfied
   --> src/gpu/backends/hybrid_backend.rs:443:45
    |
443 |         let mut buffer = UnifiedBuffer::new(data.len())?;
    |                          ------------------ ^^^^^^^^^^ the trait `Clone` is not implemented for `T`
    |                          |
    |                          required by a bound introduced by this call
    |
note: required by a bound in `UnifiedBuffer::<T>::new`
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/memory/unified.rs:333:22
    |
333 | impl<T: DeviceCopy + Clone> UnifiedBuffer<T> {
    |                      ^^^^^ required by this bound in `UnifiedBuffer::<T>::new`
...
350 |     pub fn new(value: &T, size: usize) -> CudaResult<Self> {
    |            --- required by a bound in this associated function
help: consider further restricting type parameter `T` with trait `Clone`
    |
439 |     pub fn allocate_unified_buffer<T: rustacuda::memory::DeviceCopy + zeroize::Zeroize + std::clone::Clone>(
    |                                                                                        +++++++++++++++++++
help: consider removing this method call, as the receiver has type `&[T]` and `&[T]: Clone` trivially holds
    |
443 -         let mut buffer = UnifiedBuffer::new(data.len())?;
443 +         let mut buffer = UnifiedBuffer::new(data)?;
    |

error[E0277]: the trait bound `Vec<u8>: DeviceCopy` is not satisfied
   --> src/gpu/backends/hybrid_backend.rs:565:45
    |
565 |             let buffer = UnifiedBuffer::new(&vec![0u8; size])?;
    |                          ------------------ ^^^^^^^^^^^^^^^^ the trait `DeviceCopy` is not implemented for `Vec<u8>`
    |                          |
    |                          required by a bound introduced by this call
    |
    = help: the following other types implement trait `DeviceCopy`:
              ()
              (A, B)
              (A, B, C)
              (A, B, C, D)
              (A, B, C, D, E)
              (A, B, C, D, E, F)
              (A, B, C, D, E, F, G)
              (A, B, C, D, E, F, G, H)
            and 59 others
note: required by a bound in `UnifiedBuffer::<T>::new`
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/memory/unified.rs:333:9
    |
333 | impl<T: DeviceCopy + Clone> UnifiedBuffer<T> {
    |         ^^^^^^^^^^ required by this bound in `UnifiedBuffer::<T>::new`
...
350 |     pub fn new(value: &T, size: usize) -> CudaResult<Self> {
    |            --- required by a bound in this associated function

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src/gpu/backends/hybrid_backend.rs:565:26
    |
565 |             let buffer = UnifiedBuffer::new(&vec![0u8; size])?;
    |                          ^^^^^^^^^^^^^^^^^^------------------ argument #2 of type `usize` is missing
    |
note: associated function defined here
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/memory/unified.rs:350:12
    |
350 |     pub fn new(value: &T, size: usize) -> CudaResult<Self> {
    |            ^^^
help: provide the argument
    |
565 |             let buffer = UnifiedBuffer::new(&vec![0u8; size], /* usize */)?;
    |                                                             +++++++++++++

error[E0277]: the trait bound `Vec<u8>: DeviceCopy` is not satisfied
   --> src/gpu/backends/hybrid_backend.rs:565:26
    |
565 |             let buffer = UnifiedBuffer::new(&vec![0u8; size])?;
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `DeviceCopy` is not implemented for `Vec<u8>`
    |
    = help: the following other types implement trait `DeviceCopy`:
              ()
              (A, B)
              (A, B, C)
              (A, B, C, D)
              (A, B, C, D, E)
              (A, B, C, D, E, F)
              (A, B, C, D, E, F, G)
              (A, B, C, D, E, F, G, H)
            and 59 others
note: required by a bound in `UnifiedBuffer`
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/memory/unified.rs:329:29
    |
329 | pub struct UnifiedBuffer<T: DeviceCopy> {
    |                             ^^^^^^^^^^ required by this bound in `UnifiedBuffer`

error[E0277]: the trait bound `Vec<u8>: DeviceCopy` is not satisfied
   --> src/gpu/backends/hybrid_backend.rs:565:26
    |
565 |             let buffer = UnifiedBuffer::new(&vec![0u8; size])?;
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `DeviceCopy` is not implemented for `Vec<u8>`
    |
    = help: the following other types implement trait `DeviceCopy`:
              ()
              (A, B)
              (A, B, C)
              (A, B, C, D)
              (A, B, C, D, E)
              (A, B, C, D, E, F)
              (A, B, C, D, E, F, G)
              (A, B, C, D, E, F, G, H)
            and 59 others
note: required by a bound in `UnifiedBuffer`
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustacuda-0.1.2/src/memory/unified.rs:329:29
    |
329 | pub struct UnifiedBuffer<T: DeviceCopy> {
    |                             ^^^^^^^^^^ required by this bound in `UnifiedBuffer`

error[E0308]: mismatched types
   --> src/gpu/backends/hybrid_backend.rs:566:35
    |
566 |             Ok(SharedBuffer::Cuda(buffer))
    |                ------------------ ^^^^^^ expected `UnifiedBuffer<u8>`, found `UnifiedBuffer<Vec<u8>>`
    |                |
    |                arguments to this enum variant are incorrect
    |
    = note: expected struct `UnifiedBuffer<u8>`
               found struct `UnifiedBuffer<Vec<u8>>`
note: tuple variant defined here
   --> src/gpu/backends/hybrid_backend.rs:591:5
    |
591 |     Cuda(rustacuda::memory::UnifiedBuffer<u8>),
    |     ^^^^

error[E0560]: struct `RhoState` has no field named `bias_mod`
   --> src/gpu/hybrid_manager.rs:337:21
    |
337 |                     bias_mod,
    |                     ^^^^^^^^ `RhoState` does not have this field
    |
    = note: available fields are: `is_dp`

error[E0599]: no method named `create_state_buffer` found for struct `CudaBackend` in the current scope
   --> src/gpu/hybrid_manager.rs:342:32
    |
342 |             match cuda_backend.create_state_buffer(&rho_states) {
    |                                ^^^^^^^^^^^^^^^^^^^ method not found in `CudaBackend`
    |
   ::: src/gpu/backends/cuda_backend.rs:13:1
    |
 13 | pub struct CudaBackend {
    | ---------------------- method `create_state_buffer` not found for this struct

error[E0599]: no method named `launch_rho_kernel` found for struct `CudaBackend` in the current scope
   --> src/gpu/hybrid_manager.rs:344:37
    |
344 | ...   if cuda_backend.launch_rho_kernel(&d_states, num_walks as u32, BigInt256::from_u64(bias_mod))....
    |                       ^^^^^^^^^^^^^^^^^ method not found in `CudaBackend`
    |
   ::: src/gpu/backends/cuda_backend.rs:13:1
    |
 13 | pub struct CudaBackend {
    | ---------------------- method `launch_rho_kernel` not found for this struct

error[E0599]: no method named `read_dp_buffer` found for struct `CudaBackend` in the current scope
   --> src/gpu/hybrid_manager.rs:346:61
    |
346 |                         if let Ok(dp_points) = cuda_backend.read_dp_buffer() {
    |                                                             ^^^^^^^^^^^^^^ method not found in `CudaBackend`
    |
   ::: src/gpu/backends/cuda_backend.rs:13:1
    |
 13 | pub struct CudaBackend {
    | ---------------------- method `read_dp_buffer` not found for this struct

error[E0599]: no method named `hash_dp_point` found for reference `&HybridGpuManager` in the current scope
   --> src/gpu/hybrid_manager.rs:382:28
    |
382 |         let dp_hash = self.hash_dp_point(dp);
    |                            ^^^^^^^^^^^^^ method not found in `&HybridGpuManager`

error[E0599]: no method named `mock_dp_table_contains` found for reference `&HybridGpuManager` in the current scope
   --> src/gpu/hybrid_manager.rs:383:17
    |
383 |         if self.mock_dp_table_contains(dp_hash) {
    |                 ^^^^^^^^^^^^^^^^^^^^^^ method not found in `&HybridGpuManager`

error[E0308]: mismatched types
   --> src/gpu/hybrid_manager.rs:392:25
    |
392 |             Some(diff % order)
    |                  ----   ^^^^^ expected `BigInt256`, found `Result<BigInt256, String>`
    |                  |
    |                  expected because this is `BigInt256`
    |
    = note: expected struct `BigInt256`
                 found enum `std::result::Result<BigInt256, std::string::String>`
help: consider using `Result::expect` to unwrap the `std::result::Result<BigInt256, std::string::String>` value, panicking if the value is a `Result::Err`
    |
392 |             Some(diff % order.expect("REASON"))
    |                              +++++++++++++++++

error[E0609]: no field `cuda` on type `&HybridGpuManager`
   --> src/gpu/hybrid_manager.rs:858:18
    |
858 |             self.cuda.batch_bsgs_solve(deltas, alphas, distances, &self.config)
    |                  ^^^^ unknown field
    |
    = note: available fields are: `hybrid_backend`, `curve`, `drift_threshold`, `config`, `metrics`

warning: unnecessary `unsafe` block
  --> src/gpu/backend.rs:27:25
   |
27 |         if let Ok(()) = unsafe { rustacuda::init(CudaFlags::empty()) } {
   |                         ^^^^^^ unnecessary `unsafe` block
   |
   = note: `#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `tame_count`
   --> src/gpu/backends/cuda_backend.rs:246:36
    |
246 | ...self, tame_count: usize, wild_count: usize, targets: &Vec<[[u32;8];3]>) -> Result<(Vec<[[u32;8];3...
    |          ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tame_count`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `wild_count`
   --> src/gpu/backends/cuda_backend.rs:246:55
    |
246 | ...size, wild_count: usize, targets: &Vec<[[u32;8];3]>) -> Result<(Vec<[[u32;8];3]>, Vec<[u32;8]>, V...
    |          ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_wild_count`

warning: unused variable: `targets`
   --> src/gpu/backends/cuda_backend.rs:246:74
    |
246 | ...: usize, targets: &Vec<[[u32;8];3]>) -> Result<(Vec<[[u32;8];3]>, Vec<[u32;8]>, Vec<[u32;8]>, Vec...
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_targets`

warning: unused variable: `base`
   --> src/gpu/backends/cuda_backend.rs:257:33
    |
257 |     fn precomp_table_glv(&self, base: [u32;24], window: u32) -> Result<Vec<[[u32;8];3]>> {
    |                                 ^^^^ help: if this is intentional, prefix it with an underscore: `_base`

warning: unused variable: `window`
   --> src/gpu/backends/cuda_backend.rs:257:49
    |
257 |     fn precomp_table_glv(&self, base: [u32;24], window: u32) -> Result<Vec<[[u32;8];3]>> {
    |                                                 ^^^^^^ help: if this is intentional, prefix it with an underscore: `_window`

warning: unused variable: `positions`
   --> src/gpu/backends/cuda_backend.rs:262:26
    |
262 | ...&self, positions: &mut Vec<[[u32;8];3]>, distances: &mut Vec<[u32;8]>, types: &Vec<u32>) -> Resul...
    |           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_positions`

warning: unused variable: `distances`
   --> src/gpu/backends/cuda_backend.rs:262:60
    |
262 | ...];3]>, distances: &mut Vec<[u32;8]>, types: &Vec<u32>) -> Result<Vec<Trap>> {
    |           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_distances`

warning: unused variable: `types`
   --> src/gpu/backends/cuda_backend.rs:262:90
    |
262 | ...<[u32;8]>, types: &Vec<u32>) -> Result<Vec<Trap>> {
    |               ^^^^^ help: if this is intentional, prefix it with an underscore: `_types`

warning: unused variable: `positions`
   --> src/gpu/backends/cuda_backend.rs:267:31
    |
267 | ...&self, positions: &mut Vec<[[u32;8];3]>, distances: &mut Vec<[u32;8]>, types: &Vec<u32>, config: ...
    |           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_positions`

warning: unused variable: `distances`
   --> src/gpu/backends/cuda_backend.rs:267:65
    |
267 | ...];3]>, distances: &mut Vec<[u32;8]>, types: &Vec<u32>, config: &crate::config::Config) -> Result<...
    |           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_distances`

warning: unused variable: `types`
   --> src/gpu/backends/cuda_backend.rs:267:95
    |
267 | ...<[u32;8]>, types: &Vec<u32>, config: &crate::config::Config) -> Result<Vec<Trap>> {
    |               ^^^^^ help: if this is intentional, prefix it with an underscore: `_types`

warning: unused variable: `config`
   --> src/gpu/backends/cuda_backend.rs:267:113
    |
267 | ...Vec<u32>, config: &crate::config::Config) -> Result<Vec<Trap>> {
    |              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_config`

warning: unused variable: `modulus`
   --> src/gpu/backends/cuda_backend.rs:272:47
    |
272 |     fn batch_inverse(&self, a: &Vec<[u32;8]>, modulus: [u32;8]) -> Result<Vec<Option<[u32;8]>>> {
    |                                               ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_modulus`

warning: unused variable: `targets`
   --> src/gpu/backends/cuda_backend.rs:277:47
    |
277 | ...pEntry>, targets: &Vec<[[u32;8];3]>) -> Result<Vec<Option<[u32;8]>>> {
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_targets`

warning: unused variable: `alpha_w`
   --> src/gpu/backends/cuda_backend.rs:282:60
    |
282 | ...u32;8]>, alpha_w: Vec<[u32;8]>, beta_t: Vec<[u32;8]>, beta_w: Vec<[u32;8]>, target: Vec<[u32;8]>,...
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_alpha_w`

warning: unused variable: `beta_t`
   --> src/gpu/backends/cuda_backend.rs:282:83
    |
282 | ...[u32;8]>, beta_t: Vec<[u32;8]>, beta_w: Vec<[u32;8]>, target: Vec<[u32;8]>, n: [u32;8]) -> Result...
    |              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_beta_t`

warning: unused variable: `beta_w`
   --> src/gpu/backends/cuda_backend.rs:282:105
    |
282 | ...[u32;8]>, beta_w: Vec<[u32;8]>, target: Vec<[u32;8]>, n: [u32;8]) -> Result<Vec<Option<[u32;8]>>> {
    |              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_beta_w`

warning: unused variable: `target`
   --> src/gpu/backends/cuda_backend.rs:282:127
    |
282 | ...[u32;8]>, target: Vec<[u32;8]>, n: [u32;8]) -> Result<Vec<Option<[u32;8]>>> {
    |              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `n`
   --> src/gpu/backends/cuda_backend.rs:282:149
    |
282 | ... Vec<[u32;8]>, n: [u32;8]) -> Result<Vec<Option<[u32;8]>>> {
    |                   ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `alphas`
   --> src/gpu/backends/cuda_backend.rs:287:58
    |
287 | ...2;8];3]>, alphas: Vec<[u32;8]>, distances: Vec<[u32;8]>, config: &crate::config::Config) -> Resul...
    |              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_alphas`

warning: unused variable: `distances`
   --> src/gpu/backends/cuda_backend.rs:287:80
    |
287 | ...2;8]>, distances: Vec<[u32;8]>, config: &crate::config::Config) -> Result<Vec<Option<[u32;8]>>> {
    |           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_distances`

warning: unused variable: `config`
   --> src/gpu/backends/cuda_backend.rs:287:105
    |
287 | ...[u32;8]>, config: &crate::config::Config) -> Result<Vec<Option<[u32;8]>>> {
    |              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_config`

warning: unused variable: `mu`
   --> src/gpu/backends/cuda_backend.rs:292:54
    |
292 | ...ec<[u32;16]>, mu: [u32;9], modulus: [u32;8], use_montgomery: bool) -> Result<Vec<[u32;8]>> {
    |                  ^^ help: if this is intentional, prefix it with an underscore: `_mu`

warning: unused variable: `modulus`
   --> src/gpu/backends/cuda_backend.rs:292:67
    |
292 | ...[u32;9], modulus: [u32;8], use_montgomery: bool) -> Result<Vec<[u32;8]>> {
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_modulus`

warning: unused variable: `use_montgomery`
   --> src/gpu/backends/cuda_backend.rs:292:85
    |
292 | ..., mu: [u32;9], modulus: [u32;8], use_montgomery: bool) -> Result<Vec<[u32;8]>> {
    |                                     ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_use_montgomery`

warning: unused variable: `b`
   --> src/gpu/backends/cuda_backend.rs:297:50
    |
297 |     fn batch_bigint_mul(&self, a: &Vec<[u32;8]>, b: &Vec<[u32;8]>) -> Result<Vec<[u32;16]>> {
    |                                                  ^ help: if this is intentional, prefix it with an underscore: `_b`

warning: unused variable: `tame`
   --> src/gpu/backends/cuda_backend.rs:307:31
    |
307 |     fn safe_diff_mod_n(&self, tame: [u32;8], wild: [u32;8], n: [u32;8]) -> Result<[u32;8]> {
    |                               ^^^^ help: if this is intentional, prefix it with an underscore: `_tame`

warning: unused variable: `wild`
   --> src/gpu/backends/cuda_backend.rs:307:46
    |
307 |     fn safe_diff_mod_n(&self, tame: [u32;8], wild: [u32;8], n: [u32;8]) -> Result<[u32;8]> {
    |                                              ^^^^ help: if this is intentional, prefix it with an underscore: `_wild`

warning: unused variable: `n`
   --> src/gpu/backends/cuda_backend.rs:307:61
    |
307 |     fn safe_diff_mod_n(&self, tame: [u32;8], wild: [u32;8], n: [u32;8]) -> Result<[u32;8]> {
    |                                                             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `x`
   --> src/gpu/backends/cuda_backend.rs:312:30
    |
312 |     fn barrett_reduce(&self, x: &[u32;16], modulus: &[u32;8], mu: &[u32;16]) -> Result<[u32;8]> {
    |                              ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `modulus`
   --> src/gpu/backends/cuda_backend.rs:312:44
    |
312 |     fn barrett_reduce(&self, x: &[u32;16], modulus: &[u32;8], mu: &[u32;16]) -> Result<[u32;8]> {
    |                                            ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_modulus`

warning: unused variable: `mu`
   --> src/gpu/backends/cuda_backend.rs:312:63
    |
312 |     fn barrett_reduce(&self, x: &[u32;16], modulus: &[u32;8], mu: &[u32;16]) -> Result<[u32;8]> {
    |                                                               ^^ help: if this is intentional, prefix it with an underscore: `_mu`

warning: unused variable: `k`
   --> src/gpu/backends/cuda_backend.rs:317:43
    |
317 |     fn mul_glv_opt(&self, p: [[u32;8];3], k: [u32;8]) -> Result<[[u32;8];3]> {
    |                                           ^ help: if this is intentional, prefix it with an underscore: `_k`

warning: unused variable: `a`
   --> src/gpu/backends/cuda_backend.rs:322:27
    |
322 |     fn mod_inverse(&self, a: &[u32;8], modulus: &[u32;8]) -> Result<[u32;8]> {
    |                           ^ help: if this is intentional, prefix it with an underscore: `_a`

warning: unused variable: `modulus`
   --> src/gpu/backends/cuda_backend.rs:322:40
    |
322 |     fn mod_inverse(&self, a: &[u32;8], modulus: &[u32;8]) -> Result<[u32;8]> {
    |                                        ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_modulus`

warning: unused variable: `a`
   --> src/gpu/backends/cuda_backend.rs:327:26
    |
327 |     fn bigint_mul(&self, a: &[u32;8], b: &[u32;8]) -> Result<[u32;16]> {
    |                          ^ help: if this is intentional, prefix it with an underscore: `_a`

warning: unused variable: `b`
   --> src/gpu/backends/cuda_backend.rs:327:39
    |
327 |     fn bigint_mul(&self, a: &[u32;8], b: &[u32;8]) -> Result<[u32;16]> {
    |                                       ^ help: if this is intentional, prefix it with an underscore: `_b`

warning: unused variable: `a`
   --> src/gpu/backends/cuda_backend.rs:332:22
    |
332 |     fn modulo(&self, a: &[u32;16], modulus: &[u32;8]) -> Result<[u32;8]> {
    |                      ^ help: if this is intentional, prefix it with an underscore: `_a`

warning: unused variable: `modulus`
   --> src/gpu/backends/cuda_backend.rs:332:36
    |
332 |     fn modulo(&self, a: &[u32;16], modulus: &[u32;8]) -> Result<[u32;8]> {
    |                                    ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_modulus`

warning: unused variable: `k`
   --> src/gpu/backends/cuda_backend.rs:337:46
    |
337 |     fn scalar_mul_glv(&self, p: [[u32;8];3], k: [u32;8]) -> Result<[[u32;8];3]> {
    |                                              ^ help: if this is intentional, prefix it with an underscore: `_k`

warning: unused variable: `x`
   --> src/gpu/backends/cuda_backend.rs:342:25
    |
342 |     fn mod_small(&self, x: [u32;8], modulus: u32) -> Result<u32> {
    |                         ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `modulus`
   --> src/gpu/backends/cuda_backend.rs:342:37
    |
342 |     fn mod_small(&self, x: [u32;8], modulus: u32) -> Result<u32> {
    |                                     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_modulus`

warning: unused variable: `modulus`
   --> src/gpu/backends/cuda_backend.rs:347:58
    |
347 |     fn batch_mod_small(&self, points: &Vec<[[u32;8];3]>, modulus: u32) -> Result<Vec<u32>> {
    |                                                          ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_modulus`

warning: unused variable: `hare`
   --> src/gpu/backends/cuda_backend.rs:352:47
    |
352 | ...[u32;8];3], hare: [[u32;8];3], max_steps: u32) -> Result<crate::gpu::backends::RhoWalkResult> {
    |                ^^^^ help: if this is intentional, prefix it with an underscore: `_hare`

warning: unused variable: `max_steps`
   --> src/gpu/backends/cuda_backend.rs:352:66
    |
352 | ...8];3], max_steps: u32) -> Result<crate::gpu::backends::RhoWalkResult> {
    |           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_steps`

warning: unused variable: `walk`
   --> src/gpu/backends/cuda_backend.rs:361:31
    |
361 | ...walk(&self, walk: crate::gpu::backends::RhoWalkResult, targets: Vec<[[u32;8];3]>) -> Result<Optio...
    |                ^^^^ help: if this is intentional, prefix it with an underscore: `_walk`

warning: unused variable: `targets`
   --> src/gpu/backends/cuda_backend.rs:361:74
    |
361 | ...kResult, targets: Vec<[[u32;8];3]>) -> Result<Option<[u32;8]>> {
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_targets`

warning: unused variable: `num_steps`
   --> src/gpu/backends/cuda_backend.rs:366:29
    |
366 | ...&self, num_steps: usize, start_state: crate::types::KangarooState) -> Result<(Vec<crate::types::P...
    |           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_num_steps`

warning: unused variable: `start_state`
   --> src/gpu/backends/cuda_backend.rs:366:47
    |
366 | ...ize, start_state: crate::types::KangarooState) -> Result<(Vec<crate::types::Point>, Vec<crate::ma...
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_start_state`

warning: unused variable: `fail`
   --> src/gpu/backends/cuda_backend.rs:371:38
    |
371 |     fn simulate_cuda_fail(&mut self, fail: bool) {
    |                                      ^^^^ help: if this is intentional, prefix it with an underscore: `_fail`

warning: unused variable: `range_min`
   --> src/gpu/backends/cuda_backend.rs:375:36
    |
375 | ...&self, range_min: &crate::math::BigInt256, range_width: &crate::math::BigInt256) -> Result<Vec<f6...
    |           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_range_min`

warning: unused variable: `range_width`
   --> src/gpu/backends/cuda_backend.rs:375:72
    |
375 | ...256, range_width: &crate::math::BigInt256) -> Result<Vec<f64>> {
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_range_width`

warning: unused variable: `num_random`
   --> src/gpu/backends/cuda_backend.rs:380:58
    |
380 | ...f64>, num_random: usize, empirical_pos: Option<Vec<f64>>, weights: (f64, f64, f64)) -> Result<Vec...
    |          ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_num_random`

warning: unused variable: `empirical_pos`
   --> src/gpu/backends/cuda_backend.rs:380:77
    |
380 | ...e, empirical_pos: Option<Vec<f64>>, weights: (f64, f64, f64)) -> Result<Vec<f64>> {
    |       ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_empirical_pos`

warning: unused variable: `weights`
   --> src/gpu/backends/cuda_backend.rs:380:110
    |
380 | ...c<f64>>, weights: (f64, f64, f64)) -> Result<Vec<f64>> {
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_weights`

warning: unused variable: `proxy_pos`
   --> src/gpu/backends/cuda_backend.rs:385:39
    |
385 |     fn analyze_preseed_cascade(&self, proxy_pos: &[f64], bins: usize) -> Result<(Vec<f64>, Vec<f64>)> {
    |                                       ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_proxy_pos`

warning: unused variable: `bins`
   --> src/gpu/backends/cuda_backend.rs:385:58
    |
385 |     fn analyze_preseed_cascade(&self, proxy_pos: &[f64], bins: usize) -> Result<(Vec<f64>, Vec<f64>)> {
    |                                                          ^^^^ help: if this is intentional, prefix it with an underscore: `_bins`

warning: unused variable: `output_buffer`
   --> src/gpu/backends/vulkan_backend.rs:164:13
    |
164 |         let output_buffer = self.device.create_buffer(&wgpu::BufferDescriptor {
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_output_buffer`

warning: variable does not need to be mutable
   --> src/gpu/backends/vulkan_backend.rs:189:13
    |
189 |         let mut traps = Vec::new();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `modulus_bigint`
   --> src/gpu/backends/vulkan_backend.rs:234:13
    |
234 |         let modulus_bigint = self.u32_array_to_bigint(&modulus);
    |             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_modulus_bigint`

warning: unused variable: `target`
   --> src/gpu/backends/vulkan_backend.rs:258:127
    |
258 | ...[u32;8]>, target: Vec<[u32;8]>, n: [u32;8]) -> Result<Vec<Option<[u32;8]>>> {
    |              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `config`
   --> src/gpu/backends/vulkan_backend.rs:327:113
    |
327 | ...Vec<u32>, config: &crate::config::Config) -> Result<Vec<Trap>> {
    |              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_config`

warning: unused variable: `tame`
   --> src/gpu/backends/vulkan_backend.rs:338:31
    |
338 |     fn safe_diff_mod_n(&self, tame: [u32;8], wild: [u32;8], n: [u32;8]) -> Result<[u32;8]> {
    |                               ^^^^ help: if this is intentional, prefix it with an underscore: `_tame`

warning: unused variable: `wild`
   --> src/gpu/backends/vulkan_backend.rs:338:46
    |
338 |     fn safe_diff_mod_n(&self, tame: [u32;8], wild: [u32;8], n: [u32;8]) -> Result<[u32;8]> {
    |                                              ^^^^ help: if this is intentional, prefix it with an underscore: `_wild`

warning: unused variable: `n`
   --> src/gpu/backends/vulkan_backend.rs:338:61
    |
338 |     fn safe_diff_mod_n(&self, tame: [u32;8], wild: [u32;8], n: [u32;8]) -> Result<[u32;8]> {
    |                                                             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `x`
   --> src/gpu/backends/vulkan_backend.rs:344:30
    |
344 |     fn barrett_reduce(&self, x: &[u32;16], modulus: &[u32;8], mu: &[u32;16]) -> Result<[u32;8]> {
    |                              ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `modulus`
   --> src/gpu/backends/vulkan_backend.rs:344:44
    |
344 |     fn barrett_reduce(&self, x: &[u32;16], modulus: &[u32;8], mu: &[u32;16]) -> Result<[u32;8]> {
    |                                            ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_modulus`

warning: unused variable: `mu`
   --> src/gpu/backends/vulkan_backend.rs:344:63
    |
344 |     fn barrett_reduce(&self, x: &[u32;16], modulus: &[u32;8], mu: &[u32;16]) -> Result<[u32;8]> {
    |                                                               ^^ help: if this is intentional, prefix it with an underscore: `_mu`

warning: unused variable: `p`
   --> src/gpu/backends/vulkan_backend.rs:349:27
    |
349 |     fn mul_glv_opt(&self, p: [[u32;8];3], k: [u32;8]) -> Result<[[u32;8];3]> {
    |                           ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `k`
   --> src/gpu/backends/vulkan_backend.rs:349:43
    |
349 |     fn mul_glv_opt(&self, p: [[u32;8];3], k: [u32;8]) -> Result<[[u32;8];3]> {
    |                                           ^ help: if this is intentional, prefix it with an underscore: `_k`

warning: unused variable: `a`
   --> src/gpu/backends/vulkan_backend.rs:354:27
    |
354 |     fn mod_inverse(&self, a: &[u32;8], modulus: &[u32;8]) -> Result<[u32;8]> {
    |                           ^ help: if this is intentional, prefix it with an underscore: `_a`

warning: unused variable: `modulus`
   --> src/gpu/backends/vulkan_backend.rs:354:40
    |
354 |     fn mod_inverse(&self, a: &[u32;8], modulus: &[u32;8]) -> Result<[u32;8]> {
    |                                        ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_modulus`

warning: unused variable: `num_random`
   --> src/gpu/backends/vulkan_backend.rs:464:58
    |
464 | ...f64>, num_random: usize, empirical_pos: Option<Vec<f64>>, weights: (f64, f64, f64)) -> Result<Vec...
    |          ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_num_random`

warning: unused variable: `empirical_pos`
   --> src/gpu/backends/vulkan_backend.rs:464:77
    |
464 | ...e, empirical_pos: Option<Vec<f64>>, weights: (f64, f64, f64)) -> Result<Vec<f64>> {
    |       ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_empirical_pos`

warning: unused variable: `weights`
   --> src/gpu/backends/vulkan_backend.rs:464:110
    |
464 | ...c<f64>>, weights: (f64, f64, f64)) -> Result<Vec<f64>> {
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_weights`

warning: unused variable: `proxy_pos`
   --> src/gpu/backends/vulkan_backend.rs:469:39
    |
469 |     fn analyze_preseed_cascade(&self, proxy_pos: &[f64], bins: usize) -> Result<(Vec<f64>, Vec<f64>)> {
    |                                       ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_proxy_pos`

Some errors have detailed explanations: E0061, E0106, E0277, E0282, E0308, E0382, E0425, E0433, E0560...
For more information about an error, try `rustc --explain E0061`.
warning: `speedbitcrack` (lib) generated 81 warnings
error: could not compile `speedbitcrack` (lib) due to 90 previous errors; 81 warnings emitted
