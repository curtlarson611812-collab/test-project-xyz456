ðŸ” SpeedBitCrackV3 Quality Assurance Check
==========================================

1. ðŸš¨ Critical Blocker Detection
-------------------------------
[0;32mâœ… No unimplemented!() calls found[0m
[0;32mâœ… No blocking TODO comments found[0m
[0;32mâœ… No placeholder implementations found[0m

2. ðŸ”¨ Compilation Verification
-----------------------------
Running cargo check...
error: `self` parameter is only allowed in associated functions
   --> src/gpu/hybrid_manager.rs:906:43
    |
906 |     pub async fn dispatch_hybrid_balanced(&self, steps: u64, gpu_load: f64) -> Result<Option<BigInt2...
    |                                           ^^^^^ not semantically valid as function parameter
    |
    = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
   --> src/gpu/hybrid_manager.rs:933:31
    |
933 |     pub fn get_attractor_rate(&self, points: &[Point]) -> f64 {
    |                               ^^^^^ not semantically valid as function parameter
    |
    = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
   --> src/gpu/hybrid_manager.rs:942:39
    |
942 |     pub fn test_real_pubkey_attractor(&self, pubkey: &Point) -> Result<bool> {
    |                                       ^^^^^ not semantically valid as function parameter
    |
    = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
   --> src/gpu/hybrid_manager.rs:951:32
    |
951 |     pub fn dispatch_mod9_check(&self, x_limbs: &Vec<[u64;4]>) -> Result<Vec<bool>> {
    |                                ^^^^^ not semantically valid as function parameter
    |
    = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
   --> src/gpu/hybrid_manager.rs:967:39
    |
967 |     pub fn dispatch_magic9_bias_check(&self, scalars: &Vec<[u64;4]>, biases: (u8, u8, u8, bool)) -> ...
    |                                       ^^^^^ not semantically valid as function parameter
    |
    = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
   --> src/gpu/hybrid_manager.rs:986:9
    |
986 |         &self,
    |         ^^^^^ not semantically valid as function parameter
    |
    = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1042:9
     |
1042 |         &self,
     |         ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1131:28
     |
1131 |     fn compute_drift_error(&self, points: &SharedBuffer<Point>, distances: &SharedBuffer<u64>, curv...
     |                            ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1188:24
     |
1188 |     pub fn get_metrics(&self) -> DriftMetrics {
     |                        ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1193:35
     |
1193 |     pub fn dispatch_collision_gpu(&self, traps: &[Trap], target: &Point) -> Vec<Solution> {
     |                                   ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1257:34
     |
1257 |     fn dispatch_batch_bsgs_solve(&self, deltas: Vec<[[u32;8];3]>, alphas: Vec<[u32;8]>, distances: ...
     |                                  ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1272:23
     |
1272 |     fn bsgs_solve_gpu(&self, _delta: &Point, threshold: u64) -> Option<[u64; 4]> {
     |                       ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1281:28
     |
1281 |     fn compute_delta_point(&self, _trap: &Trap, target: &Point) -> Point {
     |                            ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1288:34
     |
1288 |     pub fn step_with_gold_factor(&self, kangaroos: &mut [KangarooState]) {
     |                                  ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1304:34
     |
1304 |     pub fn dispatch_dp_bloom_gpu(&self, points: &[Point]) -> Vec<bool> {
     |                                  ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1316:31
     |
1316 |     pub fn test_prime_mul_gpu(&self, target: &Point) -> Result<bool> {
     |                               ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1349:36
     |
1349 |     pub fn dispatch_prime_mul_test(&self, target: &Point) -> Result<bool> {
     |                                    ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1374:33
     |
1374 |     pub fn step_with_prime_test(&self, points: &mut [Point], current_steps: u64) -> Result<()> {
     |                                 ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1387:34
     |
1387 |     pub fn dispatch_parallel_rho(&self, _g: Point, _p: Point, _num_walks: usize) -> Option<BigInt25...
     |                                  ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error: `self` parameter is only allowed in associated functions
    --> src/gpu/hybrid_manager.rs:1395:41
     |
1395 |     pub fn dispatch_parallel_brents_rho(&self, _g: Point, _p: Point, _num_walks: usize, _bias_mod: ...
     |                                         ^^^^^ not semantically valid as function parameter
     |
     = note: associated functions are those in `impl` or `trait` definitions

error[E0432]: unresolved import `ripemd`
  --> src/puzzles.rs:14:5
   |
14 | use ripemd::Ripemd160;
   |     ^^^^^^ use of unresolved module or unlinked crate `ripemd`
   |
   = help: if you wanted to use a crate named `ripemd`, use `cargo add ripemd` to add it to your `Cargo.toml`

error[E0432]: unresolved import `ripemd`
   --> src/puzzles.rs:244:9
    |
244 |     use ripemd::Ripemd160;
    |         ^^^^^^ use of unresolved module or unlinked crate `ripemd`
    |
    = help: if you wanted to use a crate named `ripemd`, use `cargo add ripemd` to add it to your `Cargo.toml`

warning: unused import: `RhoState`
  --> src/gpu/backends/cuda_backend.rs:10:29
   |
10 | use crate::types::{DpEntry, RhoState};
   |                             ^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `std::collections::HashMap`
  --> src/gpu/backends/cuda_backend.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::ffi::CString`
  --> src/gpu/backends/cuda_backend.rs:13:5
   |
13 | use std::ffi::CString;
   |     ^^^^^^^^^^^^^^^^^

warning: unused import: `crate::math::bigint::BigInt256`
   --> src/gpu/backends/vulkan_backend.rs:394:17
    |
394 |             use crate::math::bigint::BigInt256;
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::types::Point`
    --> src/gpu/backends/vulkan_backend.rs:1209:13
     |
1209 |         use crate::types::Point;
     |             ^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::math::bigint::BigInt256`
    --> src/gpu/backends/vulkan_backend.rs:1210:13
     |
1210 |         use crate::math::bigint::BigInt256;
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `BiasMode`
  --> src/gpu/hybrid_manager.rs:13:29
   |
13 | use crate::config::{Config, BiasMode};
   |                             ^^^^^^^^

warning: unused import: `info`
  --> src/gpu/hybrid_manager.rs:16:11
   |
16 | use log::{info, warn, debug};
   |           ^^^^

warning: unused import: `std::collections::HashMap`
 --> src/gpu/memory.rs:4:5
  |
4 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Sha256`
  --> src/puzzles.rs:13:12
   |
13 | use sha2::{Sha256, Digest};
   |            ^^^^^^

error[E0277]: `&tokio::task::JoinHandle<WorkResult>` is not a future
   --> src/gpu/backends/hybrid_backend.rs:786:30
    |
786 |                 match handle.await {
    |                              ^^^^^ `&tokio::task::JoinHandle<WorkResult>` is not a future
    |
    = help: the trait `Future` is not implemented for `&tokio::task::JoinHandle<WorkResult>`
    = note: &tokio::task::JoinHandle<WorkResult> must be a future or must implement `IntoFuture` to be awaited
help: the trait `Future` is implemented for `tokio::task::JoinHandle<T>`
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.49.0/src/runtime/task/join.rs:320:1
    |
320 | impl<T> Future for JoinHandle<T> {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: `Future` is implemented for `&mut tokio::task::JoinHandle<WorkResult>`, but not for `&tokio::task::JoinHandle<WorkResult>`
    = note: required for `&tokio::task::JoinHandle<WorkResult>` to implement `IntoFuture`
help: remove the `.await`
    |
786 -                 match handle.await {
786 +                 match handle {
    |

error[E0507]: cannot move out of a shared reference
   --> src/gpu/backends/hybrid_backend.rs:901:15
    |
901 |         match &stage.operation {
    |               ^^^^^^^^^^^^^^^^
902 |             HybridOperation::StepBatch(mut positions, mut distances, types) => {
    |                                        -------------  ------------- ...and here
    |                                        |
    |                                        data moved here
    |
    = note: move occurs because these variables have types that don't implement the `Copy` trait
help: consider borrowing the pattern binding
    |
902 |             HybridOperation::StepBatch(ref mut positions, mut distances, types) => {
    |                                        +++
help: consider borrowing the pattern binding
    |
902 |             HybridOperation::StepBatch(mut positions, ref mut distances, types) => {
    |                                                       +++

error[E0382]: borrow of moved value: `current_mode`
   --> src/gpu/hybrid_manager.rs:678:24
    |
657 |         let current_mode = flow_control.current_mode.clone();
    |             ------------ move occurs because `current_mode` has type `FlowExecutionMode`, which does not implement the `Copy` trait
...
665 |                     current_mode
    |                     ------------ value moved here
...
672 |                     current_mode
    |                     ------------ value moved here
...
678 |         if new_mode != current_mode {
    |                        ^^^^^^^^^^^^ value borrowed here after move
    |
help: consider cloning the value if the performance cost is acceptable
    |
672 |                     current_mode.clone()
    |                                 ++++++++
help: consider cloning the value if the performance cost is acceptable
    |
665 |                     current_mode.clone()
    |                                 ++++++++

warning: variable does not need to be mutable
   --> src/gpu/memory.rs:633:13
    |
633 |         let mut batched_transfers = self.batch_transfers();
    |             ----^^^^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
  --> src/parity/framework.rs:63:13
   |
63 |         let mut max_error = 0.0f64;
   |             ----^^^^^^^^^
   |             |
   |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:170:13
    |
170 |         let mut max_error = 0.0f64;
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:221:13
    |
221 |         let mut max_error = 0.0f64;
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:346:13
    |
346 |         let mut passed = 0;
    |             ----^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:347:13
    |
347 |         let mut failed = 0;
    |             ----^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:348:13
    |
348 |         let mut max_error: f64 = 0.0;
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:409:13
    |
409 |         let mut max_error: f64 = 0.0;
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:429:13
    |
429 |         let mut positions: Vec<[[u32; 8]; 3]> = test_kangaroos.iter()
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:432:13
    |
432 |         let mut distances: Vec<[u32; 8]> = test_kangaroos.iter()
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:477:13
    |
477 |         let mut passed = 0;
    |             ----^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:478:13
    |
478 |         let mut failed = 0;
    |             ----^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:479:13
    |
479 |         let mut max_error: f64 = 0.0;
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:540:13
    |
540 |         let mut max_error: f64 = 0.0;
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/parity/framework.rs:589:13
    |
589 |         let mut max_error: f64 = 0.0;
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

error[E0599]: no method named `dispatch_mod9_check` found for struct `HybridGpuManager` in the current scope
    --> src/utils/pubkey_loader.rs:1078:31
     |
1078 |     let mod9_results = hybrid.dispatch_mod9_check(&x_limbs)?;
     |                               ^^^^^^^^^^^^^^^^^^^ method not found in `HybridGpuManager`
     |
    ::: src/gpu/hybrid_manager.rs:134:1
     |
 134 | pub struct HybridGpuManager {
     | --------------------------- method `dispatch_mod9_check` not found for this struct

error[E0282]: type annotations needed
    --> src/utils/pubkey_loader.rs:1084:43
     |
1084 |         if is_mod9 && is_attractor_proxy(&points[i].x_bigint()) {
     |                                           ^^^^^^^^^ cannot infer type

error[E0277]: can't compare `[u64; 4]` with `BigInt256`
    --> src/math/secp.rs:2118:14
     |
2118 |         if z == &BigInt256::from_u64(1) {
     |              ^^ no implementation for `[u64; 4] == BigInt256`
     |
     = help: the trait `PartialEq<BigInt256>` is not implemented for `[u64; 4]`
     = help: the following other types implement trait `PartialEq<Rhs>`:
               `&[T]` implements `PartialEq<Vec<U, A>>`
               `&[T]` implements `PartialEq<[U; N]>`
               `&[u8; N]` implements `PartialEq<ByteStr>`
               `&[u8; N]` implements `PartialEq<ByteString>`
               `&[u8]` implements `PartialEq<ByteStr>`
               `&[u8]` implements `PartialEq<ByteString>`
               `&[u8]` implements `PartialEq<bytes::bytes::Bytes>`
               `&[u8]` implements `PartialEq<bytes::bytes_mut::BytesMut>`
             and 31 others
     = note: required for `&[u64; 4]` to implement `PartialEq<&BigInt256>`

error[E0308]: arguments to this method are incorrect
    --> src/math/secp.rs:2119:44
     |
2119 |             let x_squared = self.barrett_p.mul(x, x);
     |                                            ^^^ -  - expected `&BigInt256`, found `&[u64; 4]`
     |                                                |
     |                                                expected `&BigInt256`, found `&[u64; 4]`
     |
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
note: method defined here
    --> src/math/bigint.rs:1013:12
     |
1013 |     pub fn mul(&self, a: &BigInt256, b: &BigInt256) -> BigInt256 {
     |            ^^^        -------------  -------------

error[E0308]: arguments to this method are incorrect
    --> src/math/secp.rs:2121:44
     |
2121 |             let y_squared = self.barrett_p.mul(y, y);
     |                                            ^^^ -  - expected `&BigInt256`, found `&[u64; 4]`
     |                                                |
     |                                                expected `&BigInt256`, found `&[u64; 4]`
     |
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
note: method defined here
    --> src/math/bigint.rs:1013:12
     |
1013 |     pub fn mul(&self, a: &BigInt256, b: &BigInt256) -> BigInt256 {
     |            ^^^        -------------  -------------

error[E0599]: no method named `inv` found for struct `BarrettReducer` in the current scope
    --> src/math/secp.rs:2125:70
     |
2125 | ...ul(&lambda, &self.barrett_p.inv(&BigInt256::from_u64(2).mul(y)));
     |                                ^^^ method not found in `BarrettReducer`
     |
    ::: src/math/bigint.rs:911:1
     |
 911 | pub struct BarrettReducer {
     | ------------------------- method `inv` not found for this struct
     |
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `inv`, perhaps you need to implement it:
             candidate #1: `Inv`

error[E0599]: no method named `mul` found for struct `BigInt256` in the current scope
    --> src/math/secp.rs:2125:98
     |
2125 | ...p.inv(&BigInt256::from_u64(2).mul(y)));
     |                                  ^^^ method not found in `BigInt256`
     |
    ::: /home/curtlarson/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:8
     |
 339 |     fn mul(self, rhs: Rhs) -> Self::Output;
     |        --- the method is available for `BigInt256` here
     |
    ::: src/math/bigint.rs:17:1
     |
  17 | pub struct BigInt256 {
     | -------------------- method `mul` not found for this struct
     |
     = help: items from traits can only be used if the trait is in scope
help: trait `Mul` which provides `mul` is implemented but not in scope; perhaps you want to import it
     |
   8 + use std::ops::Mul;
     |

error[E0599]: no method named `mul` found for struct `BigInt256` in the current scope
    --> src/math/secp.rs:2127:104
     |
2127 | ...bda), &BigInt256::from_u64(2).mul(x));
     |                                  ^^^ method not found in `BigInt256`
     |
    ::: /home/curtlarson/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:8
     |
 339 |     fn mul(self, rhs: Rhs) -> Self::Output;
     |        --- the method is available for `BigInt256` here
     |
    ::: src/math/bigint.rs:17:1
     |
  17 | pub struct BigInt256 {
     | -------------------- method `mul` not found for this struct
     |
     = help: items from traits can only be used if the trait is in scope
help: trait `Mul` which provides `mul` is implemented but not in scope; perhaps you want to import it
     |
   8 + use std::ops::Mul;
     |

error[E0308]: mismatched types
    --> src/math/secp.rs:2128:90
     |
2128 |             let y3 = self.barrett_p.sub(&self.barrett_p.mul(&lambda, &self.barrett_p.sub(x, &x3)), y);
     |                                                                                      --- ^ expected `&BigInt256`, found `&[u64; 4]`
     |                                                                                      |
     |                                                                                      arguments to this method are incorrect
     |
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
note: method defined here
    --> src/math/bigint.rs:1007:12
     |
1007 |     pub fn sub(&self, a: &BigInt256, b: &BigInt256) -> BigInt256 {
     |            ^^^        -------------

error[E0308]: mismatched types
    --> src/math/secp.rs:2128:100
     |
2128 |             let y3 = self.barrett_p.sub(&self.barrett_p.mul(&lambda, &self.barrett_p.sub(x, &x3)), y);
     |                                     --- arguments to this method are incorrect                     ^ expected `&BigInt256`, found `&[u64; 4]`
     |
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
note: method defined here
    --> src/math/bigint.rs:1007:12
     |
1007 |     pub fn sub(&self, a: &BigInt256, b: &BigInt256) -> BigInt256 {
     |            ^^^                       -------------

error[E0308]: mismatched types
    --> src/math/secp.rs:2131:20
     |
2131 |                 x: x3,
     |                    ^^ expected `[u64; 4]`, found `BigInt256`

error[E0308]: mismatched types
    --> src/math/secp.rs:2132:20
     |
2132 |                 y: y3,
     |                    ^^ expected `[u64; 4]`, found `BigInt256`

error[E0308]: mismatched types
    --> src/math/secp.rs:2133:20
     |
2133 |                 z: BigInt256::from_u64(1),
     |                    ^^^^^^^^^^^^^^^^^^^^^^ expected `[u64; 4]`, found `BigInt256`

error[E0308]: arguments to this method are incorrect
    --> src/math/secp.rs:2137:44
     |
2137 |             let z_squared = self.barrett_p.mul(z, z);
     |                                            ^^^ -  - expected `&BigInt256`, found `&[u64; 4]`
     |                                                |
     |                                                expected `&BigInt256`, found `&[u64; 4]`
     |
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
note: method defined here
    --> src/math/bigint.rs:1013:12
     |
1013 |     pub fn mul(&self, a: &BigInt256, b: &BigInt256) -> BigInt256 {
     |            ^^^        -------------  -------------

error[E0308]: arguments to this method are incorrect
    --> src/math/secp.rs:2138:44
     |
2138 |             let y_squared = self.barrett_p.mul(y, y);
     |                                            ^^^ -  - expected `&BigInt256`, found `&[u64; 4]`
     |                                                |
     |                                                expected `&BigInt256`, found `&[u64; 4]`
     |
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
note: method defined here
    --> src/math/bigint.rs:1013:12
     |
1013 |     pub fn mul(&self, a: &BigInt256, b: &BigInt256) -> BigInt256 {
     |            ^^^        -------------  -------------

error[E0308]: arguments to this method are incorrect
    --> src/math/secp.rs:2141:44
     |
2141 |             let x_squared = self.barrett_p.mul(x, x);
     |                                            ^^^ -  - expected `&BigInt256`, found `&[u64; 4]`
     |                                                |
     |                                                expected `&BigInt256`, found `&[u64; 4]`
     |
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
note: method defined here
    --> src/math/bigint.rs:1013:12
     |
1013 |     pub fn mul(&self, a: &BigInt256, b: &BigInt256) -> BigInt256 {
     |            ^^^        -------------  -------------

error[E0308]: arguments to this method are incorrect
    --> src/math/secp.rs:2146:85
     |
2146 |             let z_new = self.barrett_p.mul(&BigInt256::from_u64(2), &self.barrett_p.mul(y, z));
     |                                                                                     ^^^ -  - expected `&BigInt256`, found `&[u64; 4]`
     |                                                                                         |
     |                                                                                         expected `&BigInt256`, found `&[u64; 4]`
     |
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
note: method defined here
    --> src/math/bigint.rs:1013:12
     |
1013 |     pub fn mul(&self, a: &BigInt256, b: &BigInt256) -> BigInt256 {
     |            ^^^        -------------  -------------

error[E0308]: mismatched types
    --> src/math/secp.rs:2148:183
     |
2148 | ..._u64(2), &self.barrett_p.mul(x, &y_squared_z_squared))));
     |                             --- ^ expected `&BigInt256`, found `&[u64; 4]`
     |                             |
     |                             arguments to this method are incorrect
     |
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
note: method defined here
    --> src/math/bigint.rs:1013:12
     |
1013 |     pub fn mul(&self, a: &BigInt256, b: &BigInt256) -> BigInt256 {
     |            ^^^        -------------

error[E0308]: mismatched types
    --> src/math/secp.rs:2150:153
     |
2150 | ..._u64(2), &self.barrett_p.mul(x, &y_squared_z_squared)), &x_new)), &self.barrett_p.mul(&BigInt256...
     |                             --- ^ expected `&BigInt256`, found `&[u64; 4]`
     |                             |
     |                             arguments to this method are incorrect
     |
     = note: expected reference `&BigInt256`
                found reference `&[u64; 4]`
note: method defined here
    --> src/math/bigint.rs:1013:12
     |
1013 |     pub fn mul(&self, a: &BigInt256, b: &BigInt256) -> BigInt256 {
     |            ^^^        -------------

error[E0308]: mismatched types
    --> src/math/secp.rs:2153:20
     |
2153 |                 x: x_new,
     |                    ^^^^^ expected `[u64; 4]`, found `BigInt256`

error[E0308]: mismatched types
    --> src/math/secp.rs:2154:20
     |
2154 |                 y: y_new,
     |                    ^^^^^ expected `[u64; 4]`, found `BigInt256`

error[E0308]: mismatched types
    --> src/math/secp.rs:2155:20
     |
2155 |                 z: z_new,
     |                    ^^^^^ expected `[u64; 4]`, found `BigInt256`

error[E0599]: no function or associated item named `order` found for struct `secp::Secp256k1` in the current scope
    --> src/kangaroo/collision.rs:1222:67
     |
1222 |     !k_value.is_zero() && k_value < crate::math::secp::Secp256k1::order()
     |                                                                   ^^^^^ function or associated item not found in `secp::Secp256k1`
     |
    ::: src/math/secp.rs:188:1
     |
 188 | pub struct Secp256k1 {
     | -------------------- function or associated item `order` not found for this struct
     |
note: if you're trying to build a new `secp::Secp256k1`, consider using `secp::Secp256k1::new` which returns `secp::Secp256k1`
    --> src/math/secp.rs:278:5
     |
 278 |     pub fn new() -> Self {
     |     ^^^^^^^^^^^^^^^^^^^^

error[E0282]: type annotations needed
    --> src/gpu/hybrid_manager.rs:1238:41
     |
1238 |                     for (_i, result) in bsgs_results.into_iter().enumerate() {
     |                                         ^^^^^^^^^^^^ cannot infer type

error[E0282]: type annotations needed
    --> src/gpu/hybrid_manager.rs:1241:57
     |
1241 | ...                   let private_key: [u64; 4] = solution_array.map(|x| x as u64);
     |                                                   ^^^^^^^^^^^^^^ cannot infer type

error[E0277]: `(dyn FnOnce() + Send + Sync + 'static)` doesn't implement `std::fmt::Debug`
   --> src/gpu/memory.rs:501:5
    |
494 | #[derive(Debug)]
    |          ----- in this derive macro expansion
...
501 |     pub completion_callback: Option<Box<dyn FnOnce() + Send + Sync>>,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Debug` is not implemented for `(dyn FnOnce() + Send + Sync + 'static)`

error[E0599]: no variant or associated item named `FrequentGpuAccess` found for enum `MemoryAccessPattern` in the current scope
   --> src/gpu/memory.rs:691:77
    |
435 | pub enum MemoryAccessPattern {
    | ---------------------------- variant or associated item `FrequentGpuAccess` not found for this enum
...
691 |                    matches!(allocation.access_pattern, MemoryAccessPattern::FrequentGpuAccess) {
    |                                                                             ^^^^^^^^^^^^^^^^^ variant or associated item not found in `MemoryAccessPattern`
    |
help: there is a variant with a similar name
    |
691 -                    matches!(allocation.access_pattern, MemoryAccessPattern::FrequentGpuAccess) {
691 +                    matches!(allocation.access_pattern, MemoryAccessPattern::FrequentHostAccess) {
    |

error[E0308]: mismatched types
   --> src/gpu/memory.rs:767:9
    |
746 |     fn batch_transfers(&self) -> Vec<Vec<PendingTransfer>> {
    |                                  ------------------------- expected `Vec<Vec<PendingTransfer>>` because of return type
...
755 |                     batches.push(current_batch);
    |                     ------- here the type of `batches` is inferred to be `Vec<Vec<&PendingTransfer>>`
...
767 |         batches
    |         ^^^^^^^ expected `Vec<Vec<PendingTransfer>>`, found `Vec<Vec<&PendingTransfer>>`
    |
    = note: expected struct `Vec<Vec<PendingTransfer>>`
               found struct `Vec<Vec<&PendingTransfer>>`

error[E0609]: no field `target_pubkey` on type `&PuzzleEntry`
   --> src/puzzles.rs:247:34
    |
247 |     let pubkey_bytes = if puzzle.target_pubkey.len() >= 64 {
    |                                  ^^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `n`, `status`, `btc_reward`, `pub_key_hex`, `privkey_hex` ... and 5 others

error[E0609]: no field `target_pubkey` on type `&PuzzleEntry`
   --> src/puzzles.rs:249:31
    |
249 |         let x_bytes = &puzzle.target_pubkey[0..32];
    |                               ^^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `n`, `status`, `btc_reward`, `pub_key_hex`, `privkey_hex` ... and 5 others

error[E0609]: no field `target_pubkey` on type `&PuzzleEntry`
   --> src/puzzles.rs:250:31
    |
250 |         let y_bytes = &puzzle.target_pubkey[32..64];
    |                               ^^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `n`, `status`, `btc_reward`, `pub_key_hex`, `privkey_hex` ... and 5 others

error[E0609]: no field `target_pubkey` on type `&PuzzleEntry`
   --> src/puzzles.rs:259:16
    |
259 |         puzzle.target_pubkey.clone()
    |                ^^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `n`, `status`, `btc_reward`, `pub_key_hex`, `privkey_hex` ... and 5 others

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bs58`
   --> src/puzzles.rs:282:30
    |
282 |     let calculated_address = bs58::encode(&address_payload).into_string();
    |                              ^^^^ use of unresolved module or unlinked crate `bs58`
    |
    = help: if you wanted to use a crate named `bs58`, use `cargo add bs58` to add it to your `Cargo.toml`

error[E0609]: no field `expected_address` on type `&PuzzleEntry`
   --> src/puzzles.rs:285:48
    |
285 |     let matches = calculated_address == puzzle.expected_address;
    |                                                ^^^^^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `n`, `status`, `btc_reward`, `pub_key_hex`, `privkey_hex` ... and 5 others

error[E0609]: no field `number` on type `&PuzzleEntry`
   --> src/puzzles.rs:289:22
    |
289 |               puzzle.number, puzzle.expected_address, calculated_address);
    |                      ^^^^^^ unknown field
    |
    = note: available fields are: `n`, `status`, `btc_reward`, `pub_key_hex`, `privkey_hex` ... and 5 others

error[E0609]: no field `expected_address` on type `&PuzzleEntry`
   --> src/puzzles.rs:289:37
    |
289 |               puzzle.number, puzzle.expected_address, calculated_address);
    |                                     ^^^^^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `n`, `status`, `btc_reward`, `pub_key_hex`, `privkey_hex` ... and 5 others

error[E0609]: no field `number` on type `&PuzzleEntry`
   --> src/puzzles.rs:291:65
    |
291 |         info!("Puzzle {} address validation successful", puzzle.number);
    |                                                                 ^^^^^^ unknown field
    |
    = note: available fields are: `n`, `status`, `btc_reward`, `pub_key_hex`, `privkey_hex` ... and 5 others

warning: unused import: `Digest`
  --> src/puzzles.rs:13:20
   |
13 | use sha2::{Sha256, Digest};
   |                    ^^^^^^

warning: variable does not need to be mutable
   --> src/gpu/backends/vulkan_backend.rs:188:13
    |
188 |         let mut traps = Vec::new();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `i`
   --> src/gpu/backends/vulkan_backend.rs:447:14
    |
447 |         for (i, dp) in dps.iter().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `mu_bigint`
    --> src/gpu/backends/vulkan_backend.rs:1078:13
     |
1078 |         let mu_bigint = BigInt512 { limbs: mu_u64 }.to_bigint256();
     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_mu_bigint`

warning: unused variable: `num_random`
    --> src/gpu/backends/vulkan_backend.rs:1300:58
     |
1300 | ...f64>, num_random: usize, empirical_pos: Option<Vec<f64>>, weights: (f64, f64, f64)) -> Result<Ve...
     |          ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_num_random`

warning: unused variable: `empirical_pos`
    --> src/gpu/backends/vulkan_backend.rs:1300:77
     |
1300 | ...e, empirical_pos: Option<Vec<f64>>, weights: (f64, f64, f64)) -> Result<Vec<f64>> {
     |       ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_empirical_pos`

warning: unused variable: `weights`
    --> src/gpu/backends/vulkan_backend.rs:1300:110
     |
1300 | ...c<f64>>, weights: (f64, f64, f64)) -> Result<Vec<f64>> {
     |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_weights`

warning: unused variable: `proxy_pos`
    --> src/gpu/backends/vulkan_backend.rs:1305:39
     |
1305 | ...&self, proxy_pos: &[f64], bins: usize) -> Result<(Vec<f64>, Vec<f64>)> {
     |           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_proxy_pos`

error[E0521]: borrowed data escapes outside of method
   --> src/gpu/backends/hybrid_backend.rs:588:9
    |
585 |       fn execute_work_item(&self, work_item: WorkItem) -> tokio::task::JoinHandle<WorkResult> {
    |                            -----
    |                            |
    |                            `self` is a reference that is only valid in the method body
    |                            let's call the lifetime of this reference `'1`
...
588 | /         tokio::spawn(async move {
589 | |             match work_item.operation {
590 | |                 HybridOperation::BatchInverse(inputs, modulus) => {
591 | |                     match backend {
...   |
776 | |         })
    | |          ^
    | |          |
    | |__________`self` escapes the method body here
    |            argument requires that `'1` must outlive `'static`

warning: unused variable: `data`
   --> src/gpu/backends/hybrid_backend.rs:747:57
    |
747 |                 HybridOperation::Custom(operation_name, data) => {
    |                                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_data`

warning: unused variable: `name`
   --> src/gpu/backends/hybrid_backend.rs:849:40
    |
849 |     pub fn create_flow_pipeline(&self, name: &str, stages: Vec<FlowStage>) -> FlowPipeline {
    |                                        ^^^^ help: if this is intentional, prefix it with an underscore: `_name`

warning: unused variable: `input_data`
   --> src/gpu/backends/hybrid_backend.rs:899:59
    |
899 |     async fn execute_flow_stage(&self, stage: &FlowStage, input_data: &[u8]) -> Result<Vec<u8>> {
    |                                                           ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_input_data`

error[E0382]: use of moved value: `policy`
    --> src/gpu/backends/hybrid_backend.rs:1030:42
     |
1025 |     pub fn create_hybrid_scheduler(&self, policy: SchedulingPolicy) -> HybridScheduler {
     |                                           ------ move occurs because `policy` has type `SchedulingPolicy`, which does not implement the `Copy` trait
...
1029 |             scheduling_policy: policy,
     |                                ------ value moved here
1030 |             adaptation_enabled: matches!(policy, SchedulingPolicy::Adaptive),
     |                                          ^^^^^^ value used here after move
     |
help: consider cloning the value if the performance cost is acceptable
     |
1029 |             scheduling_policy: policy.clone(),
     |                                      ++++++++

warning: unused variable: `operation`
    --> src/gpu/backends/hybrid_backend.rs:1110:43
     |
1110 | ...&self, operation: &str, context: &SchedulingContext) -> BackendSelection {
     |           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_operation`

error[E0515]: cannot return value referencing local variable `backend`
    --> src/gpu/backends/hybrid_backend.rs:1166:24
     |
1166 |                 return BackendSelection::Backend(&backend);
     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^--------^
     |                        |                         |
     |                        |                         `backend` is borrowed here
     |                        returns a value referencing data owned by the current function

warning: unused variable: `data_size`
    --> src/gpu/backends/hybrid_backend.rs:1138:92
     |
1138 | ... &str, data_size: usize) -> BackendSelection {
     |           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_data_size`

error: lifetime may not live long enough
    --> src/gpu/backends/hybrid_backend.rs:1179:24
     |
1175 | ... select_adaptive_backend(&self, scheduler: &HybridScheduler, operation: &str, data_size: usize, ...
     |                             -                 - let's call the lifetime of this reference `'1`
     |                             |
     |                             let's call the lifetime of this reference `'2`
...
1179 | ...          return BackendSelection::Backend(&pattern.optimal_backend);
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`
     |
help: consider introducing a named lifetime parameter and update trait if needed
     |
1175 |     fn select_adaptive_backend<'a>(&self, scheduler: &'a HybridScheduler, operation: &str, data_size: usize, context: &SchedulingContext) -> BackendSelection<'a> {
     |                               ++++                    ++                                                                                                     ++++

warning: unused variable: `duration`
    --> src/gpu/backends/hybrid_backend.rs:1270:105
     |
1270 | ...: &str, duration: std::time::Duration, data_size: usize) {
     |            ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_duration`

warning: unused variable: `jumps`
    --> src/gpu/backends/hybrid_backend.rs:1639:9
     |
1639 |         jumps: &[BigInt256],
     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_jumps`

warning: unused variable: `config`
    --> src/gpu/backends/hybrid_backend.rs:1640:9
     |
1640 |         config: &Config,
     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_config`

warning: unused variable: `cuda_batch`
    --> src/gpu/backends/hybrid_backend.rs:1643:28
     |
1643 |         let (vulkan_batch, cuda_batch) = self.split_herd_for_hybrid(herd);
     |                            ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_cuda_batch`

warning: unused variable: `fail`
    --> src/gpu/backends/hybrid_backend.rs:2441:38
     |
2441 |     fn simulate_cuda_fail(&mut self, fail: bool) {
     |                                      ^^^^ help: if this is intentional, prefix it with an underscore: `_fail`

error: future cannot be sent between threads safely
   --> src/gpu/hybrid_manager.rs:300:17
    |
300 | /                 tokio::spawn(async move {
301 | |                     self_clone.execute_single_flow(&flow_id).await
302 | |                 })
    | |__________________^ future created by async block is not `Send`
    |
    = help: within `{async block@src/gpu/hybrid_manager.rs:300:30: 300:40}`, the trait `Send` is not implemented for `std::sync::MutexGuard<'_, HybridScheduler>`
note: future is not `Send` as this value is used across an await
   --> src/gpu/hybrid_manager.rs:466:66
    |
453 |         let mut scheduler = self.scheduler.lock().unwrap();
    |             ------------- has type `std::sync::MutexGuard<'_, HybridScheduler>` which is not `Send`
...
466 |                 self.execute_redundant_collision_solve(backends).await?;
    |                                                                  ^^^^^ await occurs here, with `mut scheduler` maybe used later
note: required by a bound in `tokio::spawn`
   --> /home/curtlarson/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-1.49.0/src/task/spawn.rs:171:21
    |
169 |     pub fn spawn<F>(future: F) -> JoinHandle<F::Output>
    |            ----- required by a bound in this function
170 |     where
171 |         F: Future + Send + 'static,
    |                     ^^^^ required by this bound in `spawn`

warning: unused variable: `flow`
   --> src/gpu/hybrid_manager.rs:400:21
    |
400 |         if let Some(flow) = flow_config {
    |                     ^^^^ help: if this is intentional, prefix it with an underscore: `_flow`

warning: unused variable: `work_id`
   --> src/gpu/hybrid_manager.rs:427:17
    |
427 |             let work_id = self.hybrid_backend.submit_ooo_work(
    |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_work_id`

warning: unused variable: `flow_id`
   --> src/gpu/hybrid_manager.rs:450:50
    |
450 |     async fn execute_collision_solve_flow(&self, flow_id: &str) -> Result<(), anyhow::Error> {
    |                                                  ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_flow_id`

warning: unused variable: `metrics`
   --> src/gpu/hybrid_manager.rs:654:13
    |
654 |         let metrics = &flow_control.adaptation_metrics;
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_metrics`

error[E0382]: use of moved value: `access_pattern`
   --> src/gpu/memory.rs:591:13
    |
582 | ...ub fn allocate_hybrid(&mut self, id: &str, size_bytes: usize, access_pattern: MemoryAccessPattern...
    |                                                                  -------------- move occurs because `access_pattern` has type `MemoryAccessPattern`, which does not implement the `Copy` trait
583 | ...   let strategy = self.topology.recommend_memory_strategy(size_bytes, access_pattern);
    |                                                                          -------------- value moved here
...
591 | ...       access_pattern,
    |           ^^^^^^^^^^^^^^ value used here after move
    |
note: consider changing this parameter type in method `recommend_memory_strategy` to borrow instead if owning the value isn't necessary
   --> src/gpu/memory.rs:915:83
    |
915 | ...fn recommend_memory_strategy(&self, workload_size: usize, access_pattern: MemoryAccessPattern) ->...
    |       ------------------------- in this method                               ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value
help: consider cloning the value if the performance cost is acceptable
    |
583 |         let strategy = self.topology.recommend_memory_strategy(size_bytes, access_pattern.clone());
    |                                                                                          ++++++++

error[E0382]: borrow of moved value: `location`
   --> src/gpu/memory.rs:594:49
    |
584 |         let location = self.determine_optimal_location(&strategy, &workload_type);
    |             -------- move occurs because `location` has type `MemoryLocation`, which does not implement the `Copy` trait
...
590 |             location,
    |             -------- value moved here
...
594 |             numa_node: self.determine_numa_node(&location),
    |                                                 ^^^^^^^^^ value borrowed here after move
    |
help: consider cloning the value if the performance cost is acceptable
    |
590 |             location: location.clone(),
    |                     ++++++++++++++++++

error[E0382]: use of moved value: `source`
   --> src/gpu/memory.rs:616:25
    |
606 |         let source = self.allocations.get(source_id)
    |             ------ move occurs because `source` has type `MemoryAllocation`, which does not implement the `Copy` trait
...
614 |             source,
    |             ------ value moved here
615 |             destination,
616 |             size_bytes: source.size_bytes,
    |                         ^^^^^^^^^^^^^^^^^ value used here after move
    |
help: consider cloning the value if the performance cost is acceptable
    |
614 |             source: source.clone(),
    |                   ++++++++++++++++

error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable
   --> src/gpu/memory.rs:656:25
    |
652 |         for policy in &self.optimization_engine.migration_policies {
    |                       --------------------------------------------
    |                       |
    |                       immutable borrow occurs here
    |                       immutable borrow later used here
...
656 |                         self.defragment_memory()?;
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here

error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable
   --> src/gpu/memory.rs:661:25
    |
652 |         for policy in &self.optimization_engine.migration_policies {
    |                       --------------------------------------------
    |                       |
    |                       immutable borrow occurs here
    |                       immutable borrow later used here
...
661 |                         self.rebalance_numa()?;
    |                         ^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here

error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable
   --> src/gpu/memory.rs:665:21
    |
652 |         for policy in &self.optimization_engine.migration_policies {
    |                       --------------------------------------------
    |                       |
    |                       immutable borrow occurs here
    |                       immutable borrow later used here
...
665 |                     self.compress_low_utilization()?;
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here

warning: unused variable: `workload_size`
   --> src/gpu/memory.rs:915:45
    |
915 | ...f, workload_size: usize, access_pattern: MemoryAccessPattern) -> MemoryStrategy {
    |       ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_workload_size`

warning: unused variable: `data_size`
    --> src/gpu/memory.rs:1011:42
     |
1011 | ...&self, data_size: usize, access_pattern: MemoryAccessPattern) -> MemoryLayout {
     |           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_data_size`

warning: unused variable: `cpu_add`
   --> src/parity/framework.rs:358:17
    |
358 |             let cpu_add = (a.clone() + b.clone()) % modulus.clone();
    |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_cpu_add`

warning: unused variable: `cpu_mul`
   --> src/parity/framework.rs:359:17
    |
359 |             let cpu_mul = self.curve.barrett_n.mul(&a, &b);
    |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_cpu_mul`

warning: unused variable: `a_u32`
   --> src/parity/framework.rs:361:17
    |
361 |             let a_u32 = a.to_u32_limbs();
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_a_u32`

warning: unused variable: `b_u32`
   --> src/parity/framework.rs:362:17
    |
362 |             let b_u32 = b.to_u32_limbs();
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_b_u32`

warning: unused variable: `n_u32`
   --> src/parity/framework.rs:363:17
    |
363 |             let n_u32 = modulus.to_u32_limbs();
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_n_u32`

warning: unused variable: `targets`
   --> src/parity/framework.rs:501:13
    |
501 |         let targets: Vec<[[u32; 8]; 3]> = test_dps.iter()
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_targets`

Some errors have detailed explanations: E0277, E0282, E0308, E0382, E0432, E0433, E0502, E0507, E0515...
For more information about an error, try `rustc --explain E0277`.
error: could not compile `speedbitcrack` (lib) due to 73 previous errors; 55 warnings emitted
[1;33mâš ï¸  WARNING: Compilation has errors (non-critical for quality check)[0m
