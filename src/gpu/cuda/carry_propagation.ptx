// carry_propagation.ptx - Optimized PTX kernel for carry propagation
// Uses warp shuffle for parallel prefix carry prop, loop for sum diagonal
// For 256-bit (8 limbs), grid(batch) block(16) warp per bigint (only 16 threads active)
// Optimized for minimal latency with register-based operations
.visible .entry carry_propagate_warp_shuffle(
    .param .u64 out,           // Output u64 result limbs [batch][16]
    .param .u64 products,      // Input u32 products [batch][64]
    .param .u32 batch,         // batch_size
    .param .u32 limbs          // limbs per bigint (8)
)
{
    .reg .u32 %tid, %bid;
    .reg .u64 %out_addr, %prod_base_addr, %load_addr;
    .reg .u64 %sum, %add_val, %temp_u64;
    .reg .u32 %carry32, %temp_u32, %j_min, %j_max, %j, %prod_idx, %prod_val;
    .reg .u32 %offset_u32;
    .reg .u64 %mask;
    .reg .pred %p_active, %p_temp;

    // Thread indices
    mov.u32 %bid, %ctaid.x;
    mov.u32 %tid, %tid.x;

    // Bounds check
    setp.lt.u32 %p_active, %bid, %batch;
    setp.lt.and.u32 %p_active, %tid, 16, %p_active;
    @!%p_active ret;

    // Address calc
    mul.wide.u32 %out_addr, %bid, 128;
    add.u64 %out_addr, %out_addr, %out;
    mul.wide.u32 %temp_u32, %tid, 8;
    add.u64 %out_addr, %out_addr, %temp_u32;

    mul.wide.u32 %prod_base_addr, %bid, 256;
    add.u64 %prod_base_addr, %prod_base_addr, %products;

    // Init sum
    mov.u64 %sum, 0;

    // J range
    mov.u32 %j_min, 0;
    mov.u32 %j_max, 7;
    setp.lt.u32 %p_temp, %tid, 8;
    @%p_temp mov.u32 %j_max, %tid;
    setp.ge.u32 %p_temp, %tid, 8;
    @%p_temp sub.u32 %j_min, %tid, 7;

    // Sum loop
    mov.u32 %j, %j_min;
loop_start:
    setp.le.u32 %p_active, %j, %j_max;
    @!%p_active bra loop_done;

    sub.u32 %temp_u32, %tid, %j;
    mul.lo.u32 %prod_idx, %j, 8;
    add.u32 %prod_idx, %prod_idx, %temp_u32;

    mul.lo.u32 %temp_u32, %prod_idx, 4;
    cvt.u64.u32 %temp_u64, %temp_u32;

    mov.u64 %load_addr, %prod_base_addr;
    add.u64 %load_addr, %load_addr, %temp_u64;

    ld.global.u32 %prod_val, [%load_addr];
    cvt.u64.u32 %add_val, %prod_val;
    add.u64 %sum, %sum, %add_val;

    add.u32 %j, %j, 1;
    bra.uni loop_start;

loop_done:

    // Parallel carry propagation
    // Initial low and carry
    shr.u64 %carry32, %sum, 32;
    mov.u64 %mask, 0xFFFFFFFF;
    and.b64 %sum, %sum, %mask;

    // Iterative
    mov.u32 %offset_u32, 1;
prefix_loop:
    .reg .u32 %left_carry;
    shfl.sync.up.b32 %left_carry, %carry32, %offset_u32, 0, 0xFFFFFFFF;
    setp.ge.u32 %p_temp, %tid, %offset_u32;
    @%p_temp cvt.u64.u32 %temp_u64, %left_carry;
    @%p_temp add.u64 %sum, %sum, %temp_u64;

    shr.u64 %carry32, %sum, 32;
    and.b64 %sum, %sum, %mask;

    mul.u32 %offset_u32, %offset_u32, 2;
    setp.lt.u32 %p_temp, %offset_u32, 16;
    @%p_temp bra prefix_loop;

    // Store
    st.global.u64 [%out_addr], %sum;

    ret;
}