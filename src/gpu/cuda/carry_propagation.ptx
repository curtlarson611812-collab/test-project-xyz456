// carry_propagation.ptx - Optimized PTX kernel for carry propagation
// Uses shared memory for serial carry prop, loop for sum diagonal
// For 256-bit (8 limbs), grid(batch) block(16) warp per bigint (only 16 threads active)
// Optimized for minimal latency with register-based operations
.visible .entry carry_propagate_warp_shuffle(
    .param .u64 out,           // Output u64 result limbs [batch][16]
    .param .u64 products,      // Input u32 products [batch][64]
    .param .u32 batch,         // batch_size
    .param .u32 limbs          // limbs per bigint (8)
)
{
    .reg .u32 %tid, %bid;
    .reg .u64 %out_addr, %prod_base_addr, %load_addr;
    .reg .u64 %sum, %add_val, %temp_u64;
    .reg .u32 %temp_u32, %j_min, %j_max, %j, %prod_idx, %prod_val;
    .reg .u32 %i;
    .reg .pred %p_active, %p_temp;
    .shared .u64 sh_sums[16];

    // Thread indices
    mov.u32 %bid, %ctaid.x;
    mov.u32 %tid, %tid.x;

    // Bounds check
    setp.lt.u32 %p_active, %bid, %batch;
    setp.lt.and.u32 %p_active, %tid, 16, %p_active;
    @!%p_active ret;

    // Address calc
    mul.wide.u32 %out_addr, %bid, 128;
    add.u64 %out_addr, %out_addr, %out;
    mul.wide.u32 %temp_u32, %tid, 8;
    add.u64 %out_addr, %out_addr, %temp_u32;

    mul.wide.u32 %prod_base_addr, %bid, 256;
    add.u64 %prod_base_addr, %prod_base_addr, %products;

    // Init sum
    mov.u64 %sum, 0;

    // J range
    mov.u32 %j_min, 0;
    mov.u32 %j_max, 7;
    setp.lt.u32 %p_temp, %tid, 8;
    @%p_temp mov.u32 %j_max, %tid;
    setp.ge.u32 %p_temp, %tid, 8;
    @%p_temp sub.u32 %j_min, %tid, 7;

    // Sum loop
    mov.u32 %j, %j_min;
loop_start:
    setp.le.u32 %p_active, %j, %j_max;
    @!%p_active bra loop_done;

    sub.u32 %temp_u32, %tid, %j;
    mul.lo.u32 %prod_idx, %j, 8;
    add.u32 %prod_idx, %prod_idx, %temp_u32;

    mul.lo.u32 %temp_u32, %prod_idx, 4;
    cvt.u64.u32 %temp_u64, %temp_u32;

    mov.u64 %load_addr, %prod_base_addr;
    add.u64 %load_addr, %load_addr, %temp_u64;

    ld.global.u32 %prod_val, [%load_addr];
    cvt.u64.u32 %add_val, %prod_val;
    add.u64 %sum, %sum, %add_val;

    add.u32 %j, %j, 1;
    bra.uni loop_start;

loop_done:

    // Carry propagation with shared serial
    st.shared.u64 [sh_sums + %tid*8], %sum;
    bar.sync 0;

    // Only tid=0 performs propagation
    setp.ne.u32 %p_temp, %tid, 0;
    @%p_temp bra skip_serial;

    .reg .u64 %carry;
    mov.u64 %carry, 0;

    mov.u32 %i, 0;
serial_loop:
    ld.shared.u64 %temp_u64, [sh_sums + %i*8];
    add.u64 %temp_u64, %temp_u64, %carry;
    and.b64 %sum, %temp_u64, 0xFFFFFFFF;
    st.shared.u64 [sh_sums + %i*8], %sum;
    shr.u64 %carry, %temp_u64, 32;

    add.u32 %i, %i, 1;
    setp.lt.u32 %p_temp, %i, 16;
    @%p_temp bra serial_loop;

skip_serial:
    bar.sync 0;
    ld.shared.u64 %sum, [sh_sums + %tid*8];

    // Store
    st.global.u64 [%out_addr], %sum;

    ret;
}