// carry_propagation.ptx - Custom PTX kernel for optimal carry propagation
// Uses warp shuffle instructions for fast parallel carry propagation
// Designed for 256-bit big integer operations with minimal latency

.visible .entry carry_propagate_warp_shuffle(
    .param .u64 carry_out,     // Output carry values [batch][limbs]
    .param .u32 products,      // Input products [batch][limbs*limbs]
    .param .u32 batch_size,    // Number of bigints
    .param .u32 limbs          // Limbs per bigint
)
{
    .reg .u32 %tid, %bid, %wid, %lid, %warp_size;
    .reg .u32 %batch_idx, %limb_idx, %warp_idx;
    .reg .u32 %product_val, %sum_low, %sum_high;
    .reg .u32 %carry_in, %carry_out_reg;
    .reg .pred %is_active;

    // Thread indices
    mov.u32 %tid, %tid.x;
    mov.u32 %bid, %ctaid.x;
    mov.u32 %warp_size, 32;

    // Calculate batch and limb indices
    div.u32 %batch_idx, %bid, %limbs;
    rem.u32 %limb_idx, %bid, %limbs;

    // Check bounds
    setp.lt.u32 %is_active, %batch_idx, %batch_size;
    @!%is_active ret;

    // Each warp (32 threads) handles one bigint limb
    // Threads in warp sum products contributing to this limb
    mov.u32 %carry_in, 0;
    mov.u32 %sum_low, 0;
    mov.u32 %sum_high, 0;

    // Sum all products that contribute to this output limb
    // For limb i, sum all products[j][k] where j+k = i
    .reg .u32 %j, %k, %product_idx;
    mov.u32 %j, 0;

sum_loop:
    add.u32 %k, %limb_idx, %j;  // k = limb_idx - j
    setp.ge.u32 %is_active, %k, 0;
    setp.lt.u32 %is_active, %k, %limbs;
    @!%is_active sum_continue;

    // Calculate product index: batch_idx * limbs*limbs + j * limbs + k
    mul.lo.u32 %product_idx, %batch_idx, %limbs;
    mul.lo.u32 %product_idx, %product_idx, %limbs;
    mad.lo.u32 %product_idx, %j, %limbs, %product_idx;
    add.u32 %product_idx, %product_idx, %k;

    // Load product value (simplified - would use ldg or ld.global)
    ld.global.u32 %product_val, [%products + %product_idx * 4];

    // Add to running sum with carry
    add.cc.u32 %sum_low, %sum_low, %product_val;
    addc.u32 %sum_high, %sum_high, 0;

sum_continue:
    add.u32 %j, %j, 1;
    setp.lt.u32 %is_active, %j, %limbs;
    @%is_active sum_loop;

    // Warp-level carry propagation using shuffle
    // Each thread has partial sum, now propagate carries across warp
    .reg .u32 %lane_id, %shuffle_carry;
    mov.u32 %lane_id, %tid;

    // Phase 1: Each thread computes its local carry
    shr.u32 %carry_out_reg, %sum_low, 16;  // Simplified carry detection
    mov.u32 %shuffle_carry, %carry_out_reg;

    // Phase 2: Warp shuffle to propagate carries
    // Thread 0 gets no input carry
    setp.eq.u32 %is_active, %lane_id, 0;
    @%is_active carry_propagate;

    // Other threads get carry from previous thread
    shfl.sync.idx.b32 %carry_in, %shuffle_carry, %lane_id - 1, 0x1f, -1;

carry_propagate:
    // Add input carry to sum
    add.cc.u32 %sum_low, %sum_low, %carry_in;
    addc.u32 %sum_high, %sum_high, 0;

    // Store final result limb
    .reg .u64 %output_addr;
    cvt.u64.u32 %output_addr, %batch_idx;
    mul.wide.u32 %output_addr, %output_addr, %limbs;
    add.u64 %output_addr, %output_addr, %limb_idx;
    mul.lo.u64 %output_addr, %output_addr, 8;  // 8 bytes per u64
    st.global.u32 [%carry_out + %output_addr], %sum_low;
    st.global.u32 [%carry_out + %output_addr + 4], %sum_high;

    ret;
}