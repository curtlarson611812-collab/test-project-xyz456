//! Bias Analysis and Optimization Utilities for Magic 9 Sniper
//!
//! Provides advanced bias detection, scoring, and filtering for mod9/mod27/mod81/pos
//! optimizations in secp256k1 kangaroo attacks.

use crate::math::bigint::BigInt256;
use log::{info, warn};

/// Compute target biases from pubkey x-coordinate with attractor cross-check
/// Returns (mod9, mod27, mod81, pos) bias targets
pub fn compute_pubkey_biases(x: &BigInt256, attractor_x: &BigInt256) -> (u8, u8, u8, bool) {
    let mod9 = (x.clone() % BigInt256::from_u64(9)).low_u32() as u8;
    let mod27 = (x.clone() % BigInt256::from_u64(27)).low_u32() as u8;
    let mod81 = (x.clone() % BigInt256::from_u64(81)).low_u32() as u8;
    let pos = true;  // Always positive for distance scalars

    // Optimization: Cross-check with attractor congruence for validation
    let att_mod9 = (attractor_x.clone() % BigInt256::from_u64(9)).low_u32() as u8;
    if mod9 != att_mod9 {
        log::warn!("Pubkey mod9 bias {} differs from attractor mod9 {}", mod9, att_mod9);
    }

    (mod9, mod27, mod81, pos)
}

/// Enhanced apply biases with scoring for partial matches and adaptive thresholds
/// Returns bias score (0.0 = no match, 1.0 = perfect match)
/// Updated to include strict mod3 check as base for mod9 chains
pub fn apply_biases(scalar: &BigInt256, target: (u8, u8, u8, u8, bool)) -> f64 {
    // Strict mod3 check first (base for mod9 chains) - fail immediately if mismatch
    let s_mod3 = (scalar.clone() % BigInt256::from_u64(3)).low_u32() as u8;
    if s_mod3 != target.3 {
        return 0.0;  // Strict fail
    }

    // Positional bias filter
    if target.4 && scalar.is_zero() {
        return 0.0;  // Reject zero scalars if pos bias enabled
    }

    // Weighted scoring for mod9, mod27, mod81
    let mut score = 0.0f64;
    if (scalar.clone() % BigInt256::from_u64(9)).low_u32() as u8 == target.0 {
        score += 0.3;
    }
    if (scalar.clone() % BigInt256::from_u64(27)).low_u32() as u8 == target.1 {
        score += 0.3;
    }
    if (scalar.clone() % BigInt256::from_u64(81)).low_u32() as u8 == target.2 {
        score += 0.4;
    }

    score.min(1.0)
}

/// Additional bias: mod3 check for finer granularity
/// Returns true if scalar passes mod3 filter (basic 3-power subgroup)
pub fn apply_mod3_bias(scalar: &BigInt256, target_mod3: u8) -> bool {
    (scalar.clone() % BigInt256::from_u64(3)).low_u32() as u8 == target_mod3
}

/// Additional bias: Hamming weight check for low-weight scalars
/// Returns true if scalar has low Hamming weight (optimization for EC operations)
/// Disabled for GOLD clusters (uniform Hamming=128, no filtering benefit)
pub fn apply_hamming_bias(scalar: &BigInt256, max_weight: u32, is_gold_cluster: bool) -> bool {
    if is_gold_cluster {
        // GOLD clusters have uniform Hamming=128, disable filter to avoid over-filtering
        true  // Accept all scalars for GOLD clusters
    } else {
        let bytes = scalar.to_bytes_be();
        let weight: u32 = bytes.iter().map(|b| b.count_ones()).sum();
        weight < max_weight  // Standard filtering for non-GOLD clusters
    }
}

/// Compute combined bias score across multiple filters
/// Used for adaptive threshold decisions in kangaroo walks
pub fn compute_combined_bias_score(
    scalar: &BigInt256,
    mod9_target: u8,
    mod27_target: u8,
    mod81_target: u8,
    mod3_target: u8,
    max_hamming: u32,
    is_gold_cluster: bool
) -> f64 {
    let mut score = apply_biases(scalar, (mod9_target, mod27_target, mod81_target, mod3_target, true));

    if apply_hamming_bias(scalar, max_hamming, is_gold_cluster) && !is_gold_cluster {
        score += 0.1;  // Additional hamming bonus only for non-GOLD clusters
    }

    score.min(1.0)  // Cap at perfect match
}

#[allow(unused_doc_comments)]
/// Pre-computed bias database for Magic 9 sniper mode
/// Auto-generated at build time from valuable_p2pk_pubkeys.txt
/// Format: (mod3, mod9, mod27, mod81, hamming_weight) for each of the 9 pubkeys
/// Indices: [9379, 28687, 33098, 12457, 18902, 21543, 27891, 31234, 4567]
/// Generated by build.rs from cluster analysis
include!(concat!(env!("OUT_DIR"), "/magic9_biases.rs"));

/// Get pre-computed biases for a specific Magic 9 pubkey index
/// Returns (mod3, mod9, mod27, mod81, hamming_weight)
pub fn get_magic9_bias(index: usize) -> (u8, u8, u8, u8, u32) {
    MAGIC9_BIASES.get(index).copied().unwrap_or((0, 0, 0, 0, 128))
}

/// Pre-computed D_g cache for different bias patterns (GOLD cluster + future extensions)
use std::sync::Mutex;

static D_G_CACHE: std::sync::OnceLock<Mutex<std::collections::HashMap<(u8, u8, u8, u8), BigInt256>>> =
    std::sync::OnceLock::new();

/// Get or compute pre-computed D_g for bias pattern (GOLD cluster + future extensions)
/// Get hierarchical biased primes for kangaroo initialization
/// Returns primes filtered by modulus, with fallback warnings
pub fn get_biased_primes(target_mod: u8, modulus: u64, min_primes: usize) -> Vec<u64> {
    // Use the pre-computed prime arrays from build.rs
    let all_primes = if modulus == 81 {
        // For GOLD cluster (mod81=0), use pre-computed GOLD_CLUSTER_PRIMES
        GOLD_CLUSTER_PRIMES.to_vec()
    } else if modulus == 27 {
        // For secondary fallback (mod27=0), use SECONDARY_PRIMES
        SECONDARY_PRIMES.to_vec()
    } else {
        // Fallback to all primes
        crate::kangaroo::generator::PRIME_MULTIPLIERS.to_vec()
    };

    // Filter primes that match the target modulus
    let matches: Vec<u64> = all_primes.into_iter()
        .filter(|&p| (p % modulus) as u8 == target_mod)
        .collect();

    // Warn if too few primes match
    if matches.len() < min_primes {
        eprintln!("Warning: Only {} primes match mod{}={}, minimum {}. Using all available primes.",
                 matches.len(), modulus, target_mod, min_primes);
    }

    if matches.is_empty() {
        eprintln!("Warning: No primes match mod{}={}. Using full prime set.",
                 modulus, target_mod);
        // Return all primes as fallback
        crate::kangaroo::generator::PRIME_MULTIPLIERS.to_vec()
    } else {
        matches
    }
}

/// Validate nested modulus relationships (GOLD cluster consistency check)
/// Ensures mod81=0 implies mod27=0 implies mod9=0 implies mod3=0
pub fn validate_mod_chain(bias: (u8, u8, u8, u8)) -> Result<(), String> {
    let (mod3, mod9, mod27, mod81) = bias;

    // Check nested relationships
    if mod81 != 0 && (mod27 != 0 || mod9 != 0 || mod3 != 0) {
        return Err(format!("Invalid mod chain: mod81={} but lower mods non-zero", mod81));
    }
    if mod27 != 0 && (mod9 != 0 || mod3 != 0) {
        return Err(format!("Invalid mod chain: mod27={} but lower mods non-zero", mod27));
    }
    if mod9 != 0 && mod3 != 0 {
        return Err(format!("Invalid mod chain: mod9={} but mod3={}", mod9, mod3));
    }

    // For GOLD cluster (mod81=0), all should be 0
    if mod81 == 0 && (mod27 != 0 || mod9 != 0 || mod3 != 0) {
        return Err("GOLD cluster inconsistency: mod81=0 but lower mods non-zero".to_string());
    }

    Ok(())
}

pub fn get_precomputed_d_g(attractor_x: &BigInt256, bias: (u8, u8, u8, u8, u32)) -> BigInt256 {
    let bias_key = (bias.0, bias.1, bias.2, bias.3); // mod3, mod9, mod27, mod81

    // Initialize cache if needed
    let cache_mutex = D_G_CACHE.get_or_init(|| Mutex::new(std::collections::HashMap::new()));

    // Check cache first
    {
        let cache = cache_mutex.lock().unwrap();
        if let Some(cached_d_g) = cache.get(&bias_key) {
            return cached_d_g.clone();
        }
    }

    // Compute and cache for this bias pattern
    info!("üîç Pre-computing D_g for bias pattern {:?}", bias_key);
    let curve = crate::math::secp::Secp256k1::new();

    // Generator point G in affine coordinates
    let g_x = [0x79BE667EF9DCBBAC, 0x55A06295CE870B07, 0x029BFCDB2DCE28D9, 0x59F2815B16F81798];
    let g_y = [0x483ADA7726A3C465, 0x5DA4FBFC0E1108A8, 0xFD17B448A6855419, 0x9C47D08FFB10D4B8];
    let generator = crate::types::Point::from_affine(g_x, g_y);

    // Convert bias tuple to kangaroo format
    let kangaroo_bias = (bias.1, bias.2, bias.3, true); // mod9, mod27, mod81, pos

    // Compute D_g (this is expensive, so we cache it)
    let d_g = crate::kangaroo::generator::biased_kangaroo_to_attractor(
        &generator, attractor_x, kangaroo_bias, &curve, 1_000_000
    ).unwrap_or_else(|_| {
        warn!("Failed to pre-compute D_g for pattern {:?}, using fallback", bias_key);
        BigInt256::zero()
    });

    // Cache the result
    {
        let cache_mutex = D_G_CACHE.get_or_init(|| Mutex::new(std::collections::HashMap::new()));
        let mut cache = cache_mutex.lock().unwrap();
        cache.insert(bias_key, d_g.clone());
    }

    info!("‚úÖ D_g pre-computed for pattern {:?}: {}", bias_key, d_g.to_hex());
    d_g
}