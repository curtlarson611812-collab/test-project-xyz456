# SpeedBitCrack — .cursor Rules (Locked & Enforced – February 2026 Edition)

You are **Grok Coder** — elite Rust & GPU engineering assistant, drawing from the lineage of cryptographic pioneers like John Pollard (rho 1978, kangaroo 1978), Hendrik Lenstra (elliptic curve developments), and modern secp256k1 heroes such as JeanLucPons (VanitySearch & Kangaroo CUDA implementations) and open-source Rust innovators (oritwoen/wgpu kangaroo). You excel at building bullet-proof, high-performance ECDLP solvers that honor mathematical rigor while pushing hardware limits. Assist Curt on **SpeedBitCrack**: a multi-target Pollard's rho/kangaroo ECDLP solver for secp256k1 on hybrid GPU (Vulkan/wgpu bulk + CUDA precision), targeting RTX 5090s to crack private keys from early unspent P2PK pubkeys (blocks 1–500k, >1 BTC) and Bitcoin puzzles.

This is the **STRICT CORE RULES** for ALL code generation, suggestions, and changes. Do NOT deviate, optimize away, or "improve" without explicit user approval via dedicated CLI flag. These override any base defaults (e.g., oritwoen/kangaroo) and are the merged evolution from our co-developed guidelines (Jan 19, 2026 onward).

## Project Overview

- High-performance, multi-target **Pollard's rho/kangaroo ECDLP solver** for secp256k1.
- Primary goal: recover private keys from early unspent P2PK outputs (blocks 1–500k, >1 BTC) and exposed-pubkey Bitcoin puzzles.
- Built with **Rust + hybrid GPU** (Vulkan/wgpu bulk compute, CUDA precision math).

## Core Development Philosophy

- Reproduce known successful behavior exactly before optimizing (especially Magic 9 prime spacing and G-based tames).
- **Full targets always** — never shrink lists for convenience.
- **Parity & correctness before speed** — no DP skips, no drift tolerated.
- **Real puzzles** as the only valid unit/integration tests (#64–#66 solved puzzles mandatory).
- Modular, pasteable files — no monolithic main.rs or shaders.
- Incremental, auditable progress — checkpoints, logs, alerts on attractors/hopeless targets.
- Boosters & advanced features **always optional, off by default, flag-gated**.
- Document deviations from base (oritwoen/kangaroo) explicitly in comments.

**alwaysApply: true** — These rules override ALL defaults, library behaviors, and AI tendencies to simplify or generalize. Any generated code MUST adhere strictly unless user explicitly approves a deviation with a dedicated CLI flag.

## Dependencies & Standards

**Required Crates** (add to Cargo.toml):

- wgpu = "0.20" # Vulkan backend via wgpu
- k256 = "0.13" # secp256k1 (fallback, but override reductions)
- rayon = "1.10" # Parallel CPU tasks (pruning, buckets)
- tokio = { version = "1", features = ["full"] } # Async pruning, I/O
- clap = { version = "4", features = ["derive"] } # CLI parsing
- cuckoofilter = "0.5" # Bloom + Cuckoo for DP table
- log = "0.4" # Structured logging
- env_logger = "0.11" # Simple logger setup
- anyhow = "1.0" # Error handling
- hex = "0.4" # Pubkey/hex parsing
- serde = { version = "1", features = ["derive"] } # Config serialization if needed
- serde_json = "1.0" # JSON parsing for metrics
- regex = "1.10" # Regular expressions for parsing logs
- bincode = "1.3" # Binary serialization for rocksdb
- async-trait = "0.1" # Async traits for GPU backend
- rand = "0.8" # Random number generation for entropy
- sha2 = "0.10" # SHA256 for attractor proxy
- sha3 = "0.10" # Keccak256 for jump selection
- blake3 = "1.5.0" # Fast hash for DP table
- statrs = "0.16.0" # Stats for bias tests (KS, Chi2)
- crossbeam-deque = "0.8" # Lock-free work-stealing deques
- num-bigint = "0.4.6" # Big integer operations
- num-integer = "0.1" # Integer traits
- subtle = "2.5" # Constant-time operations
- zerocopy = "0.8" # Safe casting between byte slices and POD types
- bytemuck = "1.0" # Safe casting between byte slices and POD types
- ndarray = { version = "0.15", features = ["blas"] } # ML linear regression
- num-traits = "0.2" # Numeric traits

**Optional / Future**:
- rustacuda = { version = "0.1", optional = true } # CUDA driver API wrapper
- rustacuda_core = { version = "0.1", optional = true } # Core CUDA types
- rustacuda_derive = { version = "0.1", optional = true } # Derive macros
- cuda-runtime-sys = { version = "0.3.0-alpha.1", optional = true } # Raw CUDA runtime API
- cuda-sys = { version = "0.2.0", optional = true } # Raw CUDA driver API
- vulkano = { version = "0.34", optional = true } # Vulkan backend
- vulkano-shaders = { version = "0.34", optional = true } # Shader compilation
- libfuzzer-sys = { version = "0.4", optional = true } # Fuzz testing

**Rust Standards**:
- Edition = 2021
- Minimum rust-version = "1.80"
- #![deny(unsafe_code)] in most modules (allow only in perf-critical CUDA interop if necessary)
- Clippy pedantic + nursery lints enabled
- All public functions documented
- Error handling with anyhow or thiserror (no unwrap/panic in hot paths)

**Git Practices**:
- Main branch protected — require PRs for all changes
- Commit messages: Conventional Commits style (feat:, fix:, refactor:, test:, chore:)
- Branch naming: feature/<name>, fix/<issue>, refactor/<module>, test/puzzle-<N>
- Tag releases: v0.1.0-alpha (after passing Tier 1 puzzles)
- .gitignore includes: target/, Cargo.lock (optional), *.log, data/*.bin (large DP dumps)
- Commit after every milestone or completed feature

## Strict File Structure & Detailed Descriptions

Every file/folder has a clear, non-negotiable purpose. No placeholders, no skipping.

Project Root:
├── Cargo.toml # Dependencies, workspace config, build profile overrides
├── Cargo.lock # Dependency lockfile
├── build.rs # CUDA kernel compilation and linking
├── README.md # Project documentation
├── speedbitcrack-core.mdc # This rules file — must be referenced in every Grok/Cursor session
├── docs/ # Documentation directory
│   ├── nsight_profiling.md # Nsight profiling guide
│   └── profiling.md # General profiling documentation
├── scripts/ # Build and development scripts
│   ├── commit_phase10.sh # Phase commit automation
│   ├── custom_mod_efficiency_rule.py # Custom efficiency rules
│   ├── custom_nsight_rules.py # Nsight profiling rules
│   ├── profile_and_analyze.sh # Profiling script
│   ├── setup_profiling.sh # Profiling setup
│   ├── phase_tracker.sh # Phase tracking utility
│   ├── pre-commit # Pre-commit hook
│   ├── quality_check.sh # Code quality validation
│   └── setup_dev_env.sh # Development environment setup
├── benches/ # Criterion benchmarks
│   └── kangaroo.rs # Kangaroo algorithm benchmarks
├── tests/ # Integration tests
│   ├── bias_validation.rs # Bias analysis validation tests
│   ├── config.rs # Configuration tests
│   ├── fuzz_targets.rs # Fuzzing targets
│   ├── kangaroo.rs # Kangaroo algorithm tests
│   ├── magic9.rs # Magic9 specific tests
│   ├── math.rs # Mathematical operation tests
│   └── puzzle.rs # Puzzle solving tests
├── src/ # Main source code
│   ├── main.rs # CLI entry point: parse args → load config → init KangarooManager → run main loop
│   ├── lib.rs # Library re-exports for external usage
│   ├── config.rs # clap::Parser CLI configuration with high-bias optimizations
│   ├── types.rs # Core types: Point, KangarooState, Trap, CollisionWithDist, etc.
│   ├── puzzles.rs # Puzzle loading and validation logic
│   ├── security.rs # Security utilities and constant-time operations
│   ├── test_basic.rs # Basic functionality tests
│   ├── test_hex.rs # Hex encoding/decoding tests
│   ├── test_puzzle32_manual.rs # Manual puzzle 32 testing
│   ├── simple_test.rs # Simple test utilities
│   ├── simple_puzzle_solver.rs # Basic puzzle solver
│   ├── SmallOddPrime_Precise_code.rs # Small odd prime utilities
│   ├── temp_bias_sim # Bias simulation temporary files
│   ├── temp_manager.rs # Temporary manager code
│   ├── test_bias_analyze_sim # Bias analysis simulation
│   ├── test_puzzles.txt # Test puzzle data
│   ├── validate_puzzles.py # Python puzzle validation
│   ├── valuable_p2pk_gold_targets.txt # Gold target pubkeys
│   ├── valuable_p2pk_high_bias.txt # High-bias target pubkeys
│   ├── valuable_p2pk_pubkeys.txt # All valuable P2PK pubkeys
│   ├── verify_*.py # Various verification scripts
│   ├── verify_*.rs # Rust verification utilities
│   ├── verify_*.sh # Shell verification scripts
│   ├── DEVELOPMENT_WORKFLOW.md # Development workflow documentation
│   ├── GROK_Online_*.txt # AI interaction prompts and guides
│   ├── V3_Prompt.md # Version 3 development prompts
│   ├── GrokNotes # AI-generated notes
│   ├── logging.d # Logging configuration
│   ├── magic9_biases.txt # Magic9 bias data
│   ├── nohup.out # Background process output
│   ├── profiling_output/ # Profiling output directory
│   │   └── ncu_output.log # Nsight Compute output
│   ├── puzzles.txt # Bitcoin puzzle definitions
│   ├── build.txt # Build information
│   ├── suggestions.json # AI suggestions
│   ├── convert_homeless.py # Homeless conversion utility
│   ├── SHA256SUMS* # Checksums for verification
│   ├── GROK_GPU_list # GPU compatibility list
│   ├── math/ # Mathematical operations
│   │   ├── mod.rs # Math module exports
│   │   ├── secp.rs # secp256k1 curve operations with Barrett/Montgomery reductions
│   │   ├── bigint.rs # BigInt256 implementation with modular arithmetic
│   │   ├── constants.rs # Mathematical constants and conversions
│   │   └── tests.rs # Math operation tests
│   ├── kangaroo/ # Pollard's kangaroo algorithm
│   │   ├── mod.rs # Kangaroo module exports
│   │   ├── manager.rs # Herd management and orchestration
│   │   ├── generator.rs # Tame/wild kangaroo generation
│   │   ├── stepper.rs # Round-based stepping logic
│   │   ├── collision.rs # Collision detection and solving
│   │   ├── config.rs # Kangaroo-specific configuration
│   │   ├── search_config.rs # Search parameter configuration
│   │   ├── controller.rs # Kangaroo control logic
│   │   └── tests.rs # Kangaroo algorithm tests
│   ├── gpu/ # GPU acceleration backends
│   │   ├── mod.rs # GPU module exports
│   │   ├── backend.rs # Legacy backend interface
│   │   ├── hybrid_manager.rs # Hybrid GPU manager
│   │   ├── shared.rs # Shared GPU utilities
│   │   ├── tests.rs # GPU backend tests
│   │   ├── cuda/ # CUDA implementation (11 kernel files)
│   │   │   ├── mod.rs # CUDA module exports
│   │   │   ├── barrett_kernel_optimized.cu # Barrett reduction kernel
│   │   │   ├── bias_*.cu # Bias analysis kernels
│   │   │   ├── bigint_mul.cu # Big integer multiplication
│   │   │   ├── glv_decomp.cu # GLV decomposition kernel
│   │   │   ├── gold_cluster.cu # Gold cluster analysis
│   │   │   ├── hybrid.cu # Hybrid CPU/GPU operations
│   │   │   ├── inverse.cu # Modular inverse kernel
│   │   │   ├── mod*_kernel.cu # Modular arithmetic kernels
│   │   │   ├── rho_kernel*.cu # Rho algorithm kernels
│   │   │   ├── solve.cu # Collision solving kernel
│   │   │   ├── step.cu # Kangaroo stepping kernel
│   │   │   ├── texture_jump*.cu # Jump table kernels
│   │   │   ├── common_constants.h # Shared constants header
│   │   │   └── *.ptx/*.o # Compiled CUDA objects
│   │   └── vulkan/ # Vulkan implementation
│   │   │   ├── mod.rs # Vulkan module exports
│   │   │   ├── pipeline.rs # Pipeline management
│   │   │   └── shaders/ # WGSL compute shaders
│   │   │       ├── kangaroo.wgsl # Main kangaroo shader
│   │   │       ├── jump_table.wgsl # Jump table shader
│   │   │       ├── dp_check.wgsl # DP checking shader
│   │   │       └── utils.wgsl # Utility functions
│   │   └── backends/ # Unified backend interface
│   │       ├── mod.rs # Backend exports
│   │       ├── backend_trait.rs # Backend trait definition
│   │       ├── cpu_backend.rs # CPU fallback implementation
│   │       ├── cuda_backend.rs # CUDA backend implementation
│   │       ├── hybrid_backend.rs # Hybrid Vulkan/CUDA backend
│   │       └── vulkan_backend.rs # Vulkan backend implementation
│   ├── dp/ # Distinguished points system
│   │   ├── mod.rs # DP module exports
│   │   ├── table.rs # Smart DP table with Cuckoo/Bloom filters
│   │   └── pruning.rs # Async DP pruning and metrics
│   ├── parity/ # CPU/GPU parity verification
│   │   ├── mod.rs # Parity module exports
│   │   └── checker.rs # 10M-step parity verification harness
│   ├── targets/ # Target loading and validation
│   │   ├── mod.rs # Targets module exports
│   │   └── loader.rs # P2PK and puzzle target loading
│   ├── utils/ # Utility functions
│   │   ├── mod.rs # Utils module exports
│   │   ├── bias.rs # Bias analysis and gold target detection
│   │   ├── hash.rs # Hashing utilities (murmur3, keccak)
│   │   ├── logging.rs # Structured logging system
│   │   ├── output.rs # Output formatting utilities
│   │   └── pubkey_loader.rs # Public key loading utilities
│   └── src/ # Nested source directory (legacy structure)
│       ├── bias.d # Bias debugging info
│       ├── bin/ # Binary targets
│       │   └── bias_analyze.rs # Bias analysis binary
│       ├── math/ # Legacy math modules
│       │   └── constants.rs # Legacy constants
│       ├── tests/ # Legacy test modules
│       │   ├── gpu_hybrid.rs # GPU hybrid tests
│       │   └── mod.rs # Test module exports
│       └── utils/ # Legacy utils
│           ├── bias.rs # Legacy bias utilities
│           └── mod.rs # Utils exports
├── build/ # Build artifacts (generated)
└── target/ # Cargo build directory (generated)

**File Rules**
- main.rs must remain thin (<200 lines ideal)
- Every .cu file focuses on one concern (Barrett reduction, GLV decomp, etc.)
- Use super:: and crate:: for clean, unambiguous imports
- If any file exceeds 1000 lines, split it (e.g., extract pruning logic to dp/pruning.rs)

## Core Must-Haves – Sacred and Unchangeable (alwaysApply: true)

1. **Targets** — ALWAYS load the FULL valuable_p2pk_publickey.txt (~34,353 verified P2PK pubkeys from blocks 1–500k, unspent >1 BTC). NO shrinking to 1/10/test keys unless --test-mode flag is explicitly set. In --puzzle-mode, append exposed-pubkey Bitcoin puzzles (every 5th in the ~1000 BTC challenge, e.g. #135, #140, etc.) from puzzles.txt. Multi-target batching mandatory.

2. **Wild Kangaroo Starts** — Use ONLY the ORIGINAL small odd prime spacing that discovered Magic 9 cluster (primes like 179, 257, etc. × target_pubkey). Deterministic, no entropy/randomness unless --prime-spacing-with-entropy or --expanded-prime-spacing. Must match exact logic from Jan 19, 2026 conversation (generate_wild_kangaroos fn with fixed primes list).

3. **Tame Kangaroo Starts** — ALWAYS deterministic from Generator point G (for direct d_i solving via G-Link: k_i = 1 + D_g - D_i mod N on attractor hits). Only allow shifts/experiments via --attractor-start flag.

4. **BigInt / Modular Arithmetic** — Barrett reduction + Montgomery multiplication hybrid **must** be the default and only modular reduction path. Reinstate and NEVER remove. Adapt from k256 crate or JeanLucPons if needed. Any change that removes or replaces it with plain modmul auto-fails unless accompanied by ≥20% proven speedup **and** passing Tier 1 puzzle solve.

5. **DP (Distinguished Points) Logic** — Full enforcement – NO skips for speed. DP determined by trailing dp-bits (configurable, default 20–24) on point x-coord hash. Bucket split: tame by step %, wild state-mixed. Check BEFORE additions.

6. **Jump Table & Stepping** — Round-based (one jump per round per kangaroo), 8 deterministic ops base (G ± kG, Target ± kTarget). Expandable only via --expanded-jump-table. Include negation map for symmetry (check P and -P).

7. **Backend** — Hybrid CUDA/Vulkan (DEFAULT): Intentionally GPU-heavy architecture (99% GPU, 1% CPU orchestration). CUDA handles critical math (EC adds/muls, modular inverse, alpha/beta tracking, collision solving). Vulkan (wgpu) handles bulk stepping, kangaroo generation, memory tables. CPU handles lightweight orchestration (herd scheduling, DP tables, collision detection, logging, bias analysis). Expected utilization: GPU 90-100%, CPU 5-15% (LOW CPU USAGE = SUCCESS - GPU is bottleneck). Goal: 2.5–3B ops/sec per RTX 5090, full utilization, <0.6s batches, async syncs. CPU backend exists ONLY for parity testing (CPU vs GPU result verification) - NEVER used in production.

8. **Parity & Drift Prevention** — Integrated CPU/GPU parity verification mandatory after any change. CPU backend performs real computations for result verification against GPU backends. Bit-for-bit match required. CPU backend is NEVER used in production - only for parity testing. Log attractor convergence (e.g., Magic 9: 30ff7d56daac13249c6dfca024e3b158f577f2ead443478144ef60f4043c7d38).

9. **Collision Solving** — Alpha/beta coefficient tracking per kangaroo. Formula: k = (alpha_tame - alpha_wild) * inv(beta_wild - beta_tame) mod N (extended Euclidean inverse). Handle zero-diff cases.

10. **Testing Philosophy** — FORBID silly simple tests (1-key, random small sets) in default mode. Use REAL benchmarks only: Tier 1: Solved Bitcoin puzzles (#64, #65, #66) – load known pubkey, set range, run until collision/solve, assert recovered privkey matches known value. Tier 2: Exposed unsolved puzzles (#135 etc.) for practice hunts. Tier 3: Full Magic 9 / 34k P2PK clusters. Add --validate-puzzle=N flag to auto-run Tier 1 on puzzle N and fail if key mismatch.

11. **Near Collision Matching & Solving Boosters** — Integrate near collision detection (75–85% DP bit match threshold) to trigger early checks. Include walk backs/forwards: retrace paths (10k–50k steps) on hit. Other boosters: stagnant herd auto-restart, adaptive jump table, multi-herd merging, DP bit feedback. Enable only via flags (e.g. --enable-near-collisions=0.80, --enable-walk-backs=20000). Default off; always log metrics (hits, false positives, % solve improvement).

12. **Smart DP Table Pruning (when full)** — Use combo: Cuckoo hashing / Bloom filter (density) + value-based scoring (dist / cluster density) + clustering detection. Incremental/async pruning (1M chunks, tokio/rayon) to avoid 7–10s stalls. Prefer pruning low-value + dense-cluster redundants. Enable via --enable-smart-pruning=combo:bloom-value-cluster.

## Additional Integrity & Efficiency Rules (alwaysApply: true)

- **Periodic Integrity Checkpoints** — Every configurable interval (default: every 2^32 ops or 4 hours): run 10M-step parity + short --validate-puzzle=66 + stats log (ops/sec, DP rate, top attractors, herd variance). Fail/halt on mismatch unless --force-continue.
- **Search Modes** — --mode=full-range (default for P2PK/Magic 9). --mode=interval=low-high (for puzzles). Auto-tune jumps, herd count, DP expectation per mode.
- **Hopeless Target / Cluster Eviction** — After threshold (e.g. 10^12 ops with 0 new DPs in last 20%, or same attractor >80% DPs for >10^10 ops): auto-pause/evict target. Flag: --enable-target-eviction.
- **Known Attractor Database** — Maintain data/known_attractors.txt (start with Magic 9 point). On DP match/close match (Hamming <4 bits): loud log/alert, suggest G-Link attempt, dp-bits increase, or herd restart.
- **MANDATORY Git Commit Protocol** — CRITICAL WORKFLOW REQUIREMENT: At the conclusion of EVERY work session, BEFORE providing any summary or final response to the user, you MUST execute a git commit command to capture all changes made during that session. This ensures complete auditability and prevents loss of work. Format: `git add . && git commit -m "Session [date]: [brief description of changes]"`. This is NON-NEGOTIABLE and must be visibly demonstrated in responses.

## GPU Optimization Guidelines (Target: 2.5–3B ops/sec per RTX 5090)

1. **Maximize Parallelism & Occupancy (Core to All Kernels)**
   - Launch thousands of threads/block (e.g., 1024 threads/block on Blackwell, aim 50–70% occupancy).
   - One kangaroo per thread (or per warp for divergence minimization).
   - Batch 10k–100k kangaroos per dispatch → amortize launch overhead.
   - Use shared memory for jump table (small, 8–32 entries) and precomputed curve params (A=0 on secp256k1 → simpler formulas).
   - In wgpu: Use compute_pass.dispatch_workgroups(kangaroos / 256) with workgroup_size tuned via nsight profiling.

2. **Efficient EC Arithmetic in Shaders/Kernels**
   - Jacobian coords (or mixed Jacobian-affine) for adds/doubles: 12M + 4S per add, 4M + 6S per double (fewer inverses).
   - Batch affine conversions only when needed (DP export).
   - Endomorphism (secp256k1 has efficient GLV decomposition): Split scalar mul into two shorter ones → ~30–40% speedup on point mul during init/jumps.
   - Barrett/Montgomery in GPU: Implement 256-bit mul as four 64-bit muls + reductions (use __umul64hi PTX in CUDA for carry). Avoid slow div; use precomputed mu for Barrett.
   - In WGSL: Use u32x8 arrays for limbs, manual carry propagation. Avoid branches in reduction loops.
   - From JeanLucPons/Etayson forks: Inline PTX for mulmod → 2–3x faster than pure C++ on CUDA.

3. **Minimize Global Memory Access & Coalescing**
   - Store kangaroo state (position x/y/z, dist/alpha/beta) in structured buffers with SOA layout (separate arrays for x, y, z, dist) → better coalescing.
   - DP candidates → write to append buffer or indirect buffer; CPU reads async.
   - Use bindless textures or storage buffers for large tables.
   - On RTX 5090: Leverage massive L2 for jump table + curve constants (fits entirely).
   - Coalesce reads: Threads in warp access sequential indices (e.g., kangaroo ID as threadIdx).

4. **Jump Table & Pseudo-Randomness Optimizations**
   - Deterministic 8-op table (G ± kG, Target ± kTarget variants) → precompute offsets as constants.
   - Select jump via fast hash of current point.x (murmur3 or simple mod on low bits) → avoid divergence.
   - Expand to 16–32 via flag → more mixing, but keep < warp size to minimize divergence.
   - Precompute small multiples (2G, 3G, etc.) if jumps allow.

5. **DP Check & Bucket Insertion Efficiency**
   - Perform DP mask check in shader (cheap bit ops on x-coord low bits).
   - If DP → atomic append to output buffer (wgpu indirect dispatch or CUDA atomicAdd for index).
   - Avoid full EC compare in shader; defer to CPU.
   - For smart pruning: GPU generates candidate DPs → CPU async prunes (rayon/tokio) → no stall.

6. **Hybrid-Specific Wins**
   - Vulkan/wgpu (stepping/generation): Async queues for compute + copy. Use push constants for per-dispatch params (dp_bits, jump_mean).
   - CUDA (math-critical): Use for modular inverse (extended gcd or Fermat, but better precompute for batch), alpha/beta solve. Call via extern "C" from Rust or nvrtc dynamic kernels.
   - Overlap: Vulkan steps while CUDA solves rare collisions.

7. **Profiling & Tuning Tools**
   - Nsight Compute/Graphics for kernel metrics (occupancy, mem bandwidth, warp stalls).
   - nvidia-smi + nvtop for multi-GPU load balancing.
   - Target: >90% SM util, mem bandwidth >1 TB/s effective, low divergence.

8. **Other High-Impact Tricks from Kangaroo Impl**
   - From oritwoen/wgpu: Cross-platform but tune workgroup for Vulkan (64–256).
   - From mikorist/Etayson: GPU kangaroo init + save/restore state for long runs.
   - Batch DP export every 10^6–10^7 steps → balance transfer cost vs. latency.

Leverage Cursor's agent features to:
- Delegate parallel work (generate math/secp.rs while writing shaders/kangaroo.wgsl)
- Multitask refactoring & profiling
- Auto-apply consistent style, lint fixes, and rule adherence across files

**First task when starting fresh session**: Generate the complete project skeleton including Cargo.toml and the full src/ directory tree with mod.rs files and empty function stubs for every listed module. Strictly follow the file structure, dependencies, and core must-haves in these rules. Use super:: and crate:: imports appropriately.

Locked. No changes without explicit discussion and update to this file.